## Vue 实例

每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue **实例**开始的。

所有的 Vue 组件都是 Vue **实例**，并且接受相同的选项对象 ( 一些根实例特有的选项除外 )。

---

当一个 Vue 实例被创建时，其 `data` 对象中能找到的所有的**属性**都会被加入 Vue 的「响应式系统」中。

**问**：什么是「响应式系统」？

> **答**：当 `data` 中的**属性的值**发生改变时，视图将会产生「响应」，进行重渲染，从而更新为新的值。该特性被称为「响应式系统」。

❗️需要注意的是：只有当实例被**创建**时，`data` 中就已经存在的属性才是**响应式**的。也就是说如果在实例创建后，你再添加一个新的属性，这时候该属性是不会被添加到「响应式系统」的，比如：

```javascript
var vm = new Vue({
  // ...
})
vm.someValue = 'hi'
```

上述代码在实例创建后，再向实例添加一个新的属性，那么对 `someValue` 的改动将不会触发任何视图的更新。

所以，如果你知道你会在晚些时候需要一个属性，但是一开始它为「空」或「不存在」，那么你仅需要设置一些初始值，如 `""` 或者 `null`。

---

此外，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 `$`，以便与用户定义的属性区分开来。比如：

```javascript
var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法
vm.$watch('a', function (newValue, oldValue) {
  // 这个回调将在 `vm.a` 改变后调用
})
```

---

### 生命周期

每个 Vue 实例在被创建时都要经过一系列的初始化过程，在这个过程中也会运行一些「生命周期钩子」的 Hook 函数。

如：`created`、`mounted`、`updated`、`destroyed` 等在生命周期各个阶段的调用的钩子函数，同样的各个生命周期中的 `this` 上下文都指向调用它的 Vue 实例对象。

示例：

```javascript
new Vue({
  data: {
    a: 1
  },
  created: function () {
    // `this` 指向 vm 实例
    console.log('a is: ' + this.a)
  },
  // 也可以写成 ES6 标准
  created() {
    console.log('a is: ' + this.a)
  },
})
```

---

## 模板语法

`v-once` 指令：你也能执行一次性地插值，当数据改变时，插值处的内容**不会更新**。但请留心这会影响到该节点上的其它数据绑定，比如：

```html
<span v-once>这个将不会改变: {{ msg }}</span>
```

---

如果想在标签内添加 HTML 代码可以使用 `v-html:变量名` 以用来在标签内部插入 HTML：

```html
<p>{{ rawHtml }}</p>
<!-- 将输出普通文本 -->
<p v-html="rawHtml"></p>
<!-- 将输出真正的 HTML -->
```

❗️但是不推荐这样做，因为 Vue 不是基于字符串的模板引擎，而且动态渲染的任意 HTML 可能会非常危险。

---

在使用「Mustache」语法 (双大括号) 的文本插值时，可以使用**单个的 JavaScript 表达式**。如：

```html
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div v-bind:id="'list-' + id"></div>
```

切记：只能是「单个」以及「表达式」，而不是**语句**，**控制流**也是不会生效的。

---

`v-on`、`v-bind` 指令的缩写：

```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a :href="url">...</a>
<a @click="doSomething">...</a>
```

---

## 计算属性和侦听器

> 「对于任何复杂逻辑，你都应当使用计算属性」。

这是因为：在模板中放入太多的逻辑会让模板过重且难以维护。

---

在实例声明的时候，我们声明的每个计算属性都是一个函数，该函数需要返回计算后的结果。

实际上，我们在声明时提供的函数，会被作为每个计算属性的 **getter** 函数。

---

计算属性的其中一个特点：「计算属性是基于自身的依赖进行缓存的」。

也就是说，除非自身的依赖发生了改变，否则每一次获得到的都是**上一次计算后得到的结果的缓存**，也就是不会再次计算（ 调用 gatter 函数 ），可用于节省性能开销。

如果我们不希望缓存，则可以将计算属性改用成方法，也就是 `methods` 字段中的方法。

---

👀 在使用 `watch`（ 侦听属性 ）之前想一想能否通过 `computed`（ 计算属性 ）实现。

---

计算属性默认只有 **getter**，不过在需要时你也可以提供一个 **setter**：

```javascript
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
```

---