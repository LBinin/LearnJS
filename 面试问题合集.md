##  1. 为什么 `[1] == [1]` 为 `false` ? 

首先需要搞懂 `==` 和 `===` 的关系

**`===` 判断规则：**

如果 **类型** 不同，就 `不相等` 
	
如果两个值都是 `数值` ，并且是同一个值，那么 `相等` ( `!` 例外) 

如果两个值都是 `字符串` ，每个位置的字符都一样，那么 `相等` ，否则 `不相等` 。

如果两个值都是 `true` ，或者都是 `false` ，那么 `相等` 。 

如果两个值都是 `对象` ，且都引用自 **同一个** 对象或函数，那么 `相等` ，否则 `不相等` 。 

如果两个值都是 `null` ，或者都是 `undefined` ，那么 `相等` 。 

如果其中至少有一个是 `NaN` ，那么 `不相等` 。

**`==` 判断规则：**

如果两个值 `类型` 相同，进行 `===` 比较。 

如果两个值 `类型` 不同，他们可能相等。根据下面规则进行类型转换再比较： 

如果一个是 `null ` 、一个是 `undefined ` ，那么 `相等` 。 

如果一个是 `字符串` ，一个是 `数值` ，把 **字符串转换成数值** 后再进行比较。 

如果任一值是 `true` ，把它转换成 **1** 再比较；如果任一值是 `false` ，把它转换成 **0** 再比较。 

如果一个是 `对象` ，另一个是 `数值或字符串` ，把 **对象转换成基础类型** 的值再比较。对象转换成基础类型在第 **2** 点有提到。

任何其他组合，都 `不相等` 。

因为这两个 **Array** 对象不属于同一个 **引用对象** ，所以，这两个数组之间的比较结果为 **false** 。

## 2. 那为什么 `[1] == 1` 为 `true` ?

这是因为 `[1]` 在和 `1` 进行比较的时候，首先会被转成数字类型，而转成数字类型在实现上又是通过 **new Number()** 来完成的。

所以，`[1] == 1` 会变成 `(new Number([1])).valueOf() == 1` 。

同时，`Number` 的构造函数其实是接受一个 **字符串** 作为参数的，加上 `[1].toString()` === `'1'`，所以 `new Number([1])` 相当于写 `new Number('1')`，于是很显然 `(new Number([1])).valueOf()` 就是 1 了。

个人总结：如果一边是对象，一边是基本类型，JavaScript 会先将对象使用抽象操作 `ToPrimitive` 将对象转换成基本类型 ( Primitive ) 之后再进行比较，之后就是基本类型之间的比较了。
 
一个对象转化为基本类型的步骤如下：

> 1. 先调用该对象的 `valueOf()` 方法，如果返回值为 `基本类型` ，这个值就是最终值。
> 2. 否则，继续调用对象的 `toString()` 方法，如果返回值为 `基本类型` ，这个值就是最终值。
> 3. 都无法得到结果的话，抛出异常 `Error: Cannot convert object to primitive value` 。

    如果对象是 Date 实例，则先执行 toString() 方法

## 3. 对象深浅复制

**浅复制**

该复制方式只是**对象的引用**，obj2 与 obj1 的地址相同，任意一个被修改，另一个对象的内容也被修改。

```javascript
var obj1 = { a: 1, b : 2 }
var obj2 = obj1
```

**深复制**

有时候，我们想对对象实现值的复制，而不是对象的引用，这时候就需要**深复制**。

```javascript
function copy(obj) {
  var copy = Object.create(Object.getPrototypeOf(obj))
  var propNames = Object.getOwnPropertyNames(obj)

  propNames.forEach(function(name) {
    var desc = Object.getOwnPropertyDescriptor(obj, name)
    Object.defineProperty(copy, name, desc)
  })

  return copy
}

var obj1 = { a: 1, b: 2 }
var obj2 = copy(obj1) // obj2 looks like obj1 now
```

上面的方法可以保证遇到存取器定义（ accessor ）的属性，会拷贝对应的属性。

## 4. 在不引入临时变量的情况下，交换两个变量的值

关于引入临时变量，无非就是大家最常用的做法用来交换两个变量的值。

最普通的做法：

```JavaScript
var a = 99,
    b = 0,
    temp

temp = a
a = b
b = temp
```

> **优点**：直观，易懂。
>
> **缺点**：增加内存的使用。

接下来介绍几种不需要引入临时变量的方法以及各自的优缺点~

**1. 算术做法**：

```JavaScript
var a = 1,
    b = 2

a = a + b // a = 3, b = 2
b = a - b // a = 3, b = 1
a = a - b // a = 2, b = 1
```

> **优点**：不需要引入临时变量。
>
> **缺点**：因为 JavaScript 中，数值的精度范围是 -2^53 到 2^53。所以，加法运算会存在溢出的问题。

**2. 异或运算**

```JavaScript
var a = 1, // 二进制：0001
    b = 2  // 二进制：0010

a = a ^ b // 计算结果：a = 0011, b = 0010
b = a ^ b // 计算结果：a = 0011, b = 0001
a = a ^ b // 计算结果：a = 0010, b = 0001
```

> **优点**：不需要引入临时变量，利用 `a ^ b ^ b == a` 的方法进行数值交换，且避免了使用算术运算带来的弊端，不会发生溢出问题。
>
> **缺点**：较难记忆交换过程，不够直观。

**3. 利用语法特性交换**

```JavaScript
int a = 10
int b = 12
a = b + 0 * ( b = a )
```

> **优点**：不需要引入临时变量，一次性解决。
>
> **缺点**：这种写法是不推荐的，不同的编译器，可能会出现不同的结果。

**4. ES6的解构**

```JavaScript
let a = 1,
    b = 2

[a, b] = [b, a]
```

> **优点**：不需要引入临时变量，一次性解决，直观易懂，而且还适用于其他类型的变量进行互换。
>
> **缺点**：需要在支持 ES6 的环境下运行。

**5. 利用数组特性进行交换**

```JavaScript
var a = 1,
    b = 2

a = [a, b]
b = a[0]
a = a[1]
// 等同于
var a = 1,
    b = 2
b = [a, a = b][0]
```

> **优点**：不需要引入临时变量，直观易懂，而且还适用于其他类型的变量进行互换。
>
> **缺点**：暂无。

前三种都是需要数值类型 （ Number ），后两种可以是任意类型

还有一些其他的方法都可以做到，比如将两个变量用某个符号连接起来然后再 split 之类的方法，不过这种方法也有局限性；也许还有许多其他的巧妙方法，这里就不再一一介绍了~