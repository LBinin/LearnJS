### 算术运算符

JavaScript 提供 **9** 个算术运算符，用来完成基本的算术运算。

> 加法运算符（Addition）： **x + y**
> 
> 减法运算符（Subtraction）： **x - y**
> 
> 乘法运算符（Multiplication）： **x * y**
> 
> 除法运算符（Division）： **x / y**
> 
> 余数运算符（Remainder）： **x % y**
> 
> 自增运算符（Increment）： **++x** 或者 **x++**
> 
> 自减运算符（Decrement）： **--x** 或者 **x--**
> 
> 数值运算符（Convert to number）： **+x**
> 
> 负数值运算符（Negate）： **-x**


#### 1. 「 **+** 」加法运算符、数值运算符

加法运算符（ **+** ）是最常见的运算符之一，但是使用规则却相对复杂。因为在 JavaScript 语言里面，这个运算符可以表示两种运算，既可以处理**算术的加法**，也可以用作**字符串连接**，它们都写成 `+`。

它的算法步骤为：

1. 如果运算子是**对象**，先自动转成**原始类型**的值（即先执行该对象的 `valueOf` 方法，如果结果不是原始类型的值，再执行 `toString` 方法；如果对象是 `Date` 实例，则先执行 `toString` 方法）。
 
2. 两个运算子都是**原始类型**的值，**只要**有一个运算子是「**字符串**」，则两个运算子都转为字符串，执行字符串**连接**运算，返回的是 String 类型。

3. 如果两边都没有字符串，则两个运算子都转为数值（ Number ），然后执行加法运算，返回的是 **Number** 类型。

这种由于参数不同，而改变自身行为的现象，叫做「**重载**」（overload）。由于加法运算符是**运行时**决定到底执行那种运算，使用的时候必须很小心。

```JavaScript
// 加法
1 + 1 // 2
true + true // 2 Number(true) == 1
1 + true // 2

// 字符串连接
'1' + '1' // "11"
'1.1' + '1.1' // "1.11.1"

// 字符串与其他类型
'1' + {foo: 'bar'} // "1[object Object]"
'1' + 1 // "11"
'1' + true // "1true"
'1' + [1] // "11"

// 运算结果由于字符串的位置不同而不同
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
```

**加法**运算符一定有左右两个运算子。

如果加号只有**右边**一个运算子，就是另一个运算符，叫做「**数值运算符**」（ Convert to number ）。

> 数值运算符用于返回右边运算子的**数值形式**。

```JavaScript
+ - 3   // 等同于 +(-3)
+ 1 + 2 // 等同于 +(1 + 2)
+ '1'   // 1
```

如果加号只有**左边**一个运算子，就会报错 😑。

```JavaScript
1 +
// SyntaxError: Unexpected end of input
```

前面说到了加法运算符有「**重载**」的情况，但是除了 **加号**，其他运算符（ 如 **减法**、**除法**和**乘法** ）都没有重载的情况。

这些运算符的规则是：所有的运算子一律转化为**数值**（ Number ）后，在进行数学运算。

```JavaScript
1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

综上所述，由于**加法**运算符与其他算术运算符存在「重载」这种差异，所以会导致一些意想不到的结果，使用的时候要小心。

```JavaScript
var now = new Date()
typeof (now + 1) // "string"
typeof (now - 1) // "number"
```

**解析**：

**遇到加号**，因为左运算子 `now` 是**对象**，而且是 `Date` 对象，先调用其 `toString()` 方法得到原始数据类型 `String` （ 如：`Mon Jan 01 2018 01:49:43 GMT+0800 (CST)` ），然后进行字符串的连接，最后的结果还是字符串类型；

**遇到减号**，不存在重载的问题，一律转换为 **Number** 类型（如：`1514742583083`），然后进行数学运算，所以最后返回的结果是数值类型。


#### 2. 「 **-** 」减法运算符、负数值运算符

减法运算符（-）是一个二元运算符（需要两个操作数），运算的规则也在上面的「+」运算符中介绍过了，这里就不再赘述，主要来说一下「**负数值运算符**」。

「**负数值运算符**」它是一元运算符（只需要一个操作数）。也同样具有将一个值转为**数值**的功能，只不过得到的**值正负相反**，注意是相反，而不是一定得到的是负数。连用两个负数值运算符，等同于数值运算符。

```JavaScript
- '123'     // -123
- '-123'    // 123
- (- '123') // 123
```


#### 3. 「 **%** 」余数运算符

> 余数运算符（ **%** ）返回前一个运算子被后一个运算子除，所得的余数。

需要注意的是，运算结果的正负号由第一个运算子的正负号决定。

```JavaScript
-1 % 2 // -1
1 % -2 // 1
```

如果需要求负数的余数的话，由于规定余数大于 0，所以比如：-9 % 4 应该要等于 3，但是 JavaScript 会把 -9 前面的负号当做结果的符号。就是 先运算 9 % 4 等于 1，然后用第一个运算子的符号决定结果的正负，得到 -1。

```JavaScript
/* 求余数 */
function remainder(x, y) {
  if (x < 0) return x % y + y
  else return x % y
}
remainder(-9, 4) // 3

/* 单纯判断是否为奇数 */
function isOdd(n) {
  return Math.abs(n % 2) === 1
}
isOdd(-5) // true
isOdd(-4) // false
```

---

### 赋值运算符

除了最常见的赋值运算符「=」等号赋值，JavaScript 还提供其他 11 个复合的赋值运算符。

```JavaScript
x += y // 等同于 x = x + y
x -= y // 等同于 x = x - y
x *= y // 等同于 x = x * y
x /= y // 等同于 x = x / y
x %= y // 等同于 x = x % y
x >>= y // 等同于 x = x >> y
x <<= y // 等同于 x = x << y
x >>>= y // 等同于 x = x >>> y
x &= y // 等同于 x = x & y
x |= y // 等同于 x = x | y
x ^= y // 等同于 x = x ^ y
```

---

### 比较运算符

> 比较运算符用于比较两个值，然后返回一个**布尔值**，表示是否满足比较条件。
> 
> 比较运算符可以比较**各种类型**的值，不仅仅是数值。

JavaScript 一共提供了 8 个比较运算符。

> == 相等
>
> === 严格相等
>
> != 不相等
>
> !== 严格不相等
>
> < 小于
>
> <= 小于或等于
>
> \> 大于
>
> \>= 大于或等于

「相等运算符」和「严格相等运算符」，有自己的比较算法，详情见 [严格相等运算符](#严格相等运算符) 和 [相等运算符](#相等运算符)，实例： [为什么 [1] == [1] 为 false ?](https://github.com/LBinin/LearnJS/blob/master/%08%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86.md#1-%E4%B8%BA%E4%BB%80%E4%B9%88-1--1-%E4%B8%BA-false-) 。其他六个比较运算符的算法如下：

    1. 如果两个运算子都是字符串，则按照字典顺序比较（ 实际上是比较 Unicode 码点 ）。
     
    2. 否则，将两个运算子都转成数值，再进行比较（ 等同于调用 Number 函数 ）。

#### 1. 字符串的比较

JavaScript 引擎内部首先比较首字符的 **Unicode** 码点，如果相等，再比较第二个字符的 **Unicode** 码点，以此类推。有关 Unicode 的介绍，可以阅读一下阮老师的 [Unicode与JavaScript详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html) 这篇文章。

```JavaScript
/* 获取字符的 Unicode 码点 */
parseInt('c'.charCodeAt(0)) // 99

/* 获取字符的十六进制 Unicode */
'\\u' + parseInt('c'.charCodeAt(0)).toString(16) // '\u63'
```

```JavaScript
'cat' > 'dog' // false
```

第一个字符 `c` 的码点（ 99 ）小于 `d` 的码点（ 100 ），所以 `cat` 相比之下比 `dog` 小。


```JavaScript
'cat' < 'catalog' // true 
```

前三个字母 `cat` 的码点相同，由于第一个 `cat` 没有第四位字符，右边的 `catalog` 的第四个字符 `a` 的码点（ 99 ）相当于大于 **0**，所以比较的结果是 `catalog` 大。

```JavaScript
'cat' > 'Cat' // true 
```

小写的 `c` 的 Unicode 码点（99）大于大写的 `C` 的 Unicode 码点（67），所以返回true。

```JavaScript
'大' > '小' // false
```
上面代码中，`大` 的 Unicode 码点是 22823，`小` 是23567，因此返回 `false`。

#### 2. 原始类型的比较

这里先讨论**比较运算**，关于「相等运算符」、「严格相等运算符」的规则之后再讨论。

前面说到除了**两个相等运算符**以及运算子都是**字符串**的情况下，其他情况都是将两边的运算子都转换成数值（ Number ）后再进行数值比较

```JavaScript
5 > '4'       // true 相当于 5 > Number('4') -> 5 > 4
true > false  // true 相当于 Number(true) > Number(false) -> 1 > 0
2 > true      // true 相当于 2 > Number(true) -> 2 > 1
```

有一个特殊情况，即任何值（包括 `NaN` 本身）与 `NaN` 比较，返回的都是 `false`。

```JavaScript
1 > NaN // false
1 <= NaN // false
'1' > NaN // false
'1' <= NaN // false
NaN > NaN // false
NaN <= NaN // false
```

#### 3. 对象的比较

如果运算子是**对象**，会转为**原始类型**的值，再进行比较。

对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法。两个对象之间的比较也是如此。详细解释见「数据类型的转换」笔记。

```JavaScript
var x = [2]
x > '11' // true 相当于 [2].valueOf().toString() > '11' -> '2' > '11'

x.valueOf = function () { return '1' }
x > '11' // false 相当于 [2].valueOf() > '11' -> '1' > '11'
```

### 严格相等运算符

JavaScript 提供两种相等运算符：`==` 和 `===`。

简单说，它们的区别是相等运算符（ `==` ）比较两个**值是否相等**，严格相等运算符（ `===` ）比较它们是否为「同类型相等的值」。如果两个值不是同一类型，严格相等运算符（ `===` ）直接返回 `false`，而相等运算符（ `==` ）会将它们**转化成同一个类型**，再用严格相等运算符进行比较。

严格相等运算符的规则如下：

1. 不同类型的值

    如果两个值的类型不同，直接返回 `false`。

2. 同一类型的原始类型值

    同一类型的**原始类型**的值（数值、字符串、布尔值）比较时，值相同就返回 `true`，值不同就返回 `false`。

    需要注意的是，`NaN` 与任何值都不相等（包括自身）。另外，**正0** 等于 **负0**。

    ```JavaScript
    1 === 0x1 // true
    NaN === NaN  // false
    +0 === -0 // true
    ```

3. 同一类型的复合类型值

    同一类型的**复合类型**的值（对象、数组、函数）比较时，不是比较它们的**值是否相等**，而是比较它们是否指向同一个对象（ 是否为同一引用 ）。

    ```JavaScript
    {} === {} // false
    [] === [] // false
    (function (){} === function (){}) // false

    /* 如果两个变量引用同一个对象，则它们相等 */
    var v1 = {}
    var v2 = v1
    v1 === v2 // true
    ```

    注意，对于两个对象的比较，「严格相等运算符」比较的是**地址**，而「大于或小于运算符」比较的是**值**。

    ```JavaScript
    new Date() > new Date() // false
    new Date() < new Date() // false
    new Date() === new Date() // false
    (new Date()).valueOf() === (new Date()).valueOf() // true
    ```

    上面的四个表达式，前两个比较的是值，因为值相同；所以返回的是 `false`，第三个比较的是地址，所以返回 `false`；最后一个是比较两个对象的值是否相等，不是比较的地址，所以返回是 `true`。

4. **undefined** 和 **null**

    `undefined` 和 `null` 与**自身**严格相等，但是**两者**不严格相等。

    ```JavaScript
    undefined === undefined // true
    null === null // true
    ```

### 相等运算符

「相等运算符」比较**相同类型**的数据时，与严格相等运算符的规则完全一样。

比较**不同类型**的数据时，相等运算符会先将数据进行**类型转换**，然后再用严格相等运算符比较。类型转换规则如下。

1. 原始类型的值

    **原始类型**的数据会转换成**数值**（ Number ）类型再进行比较。

    ```JavaScript
    1 == true // true
    // 等同于 1 === 1

    0 == false // true
    // 等同于 0 === 0

    2 == true // false
    // 等同于 2 === 1

    2 == false // false
    // 等同于 2 === 0

    'true' == true // false
    // 等同于 Number('true') === Number(true)
    // 等同于 NaN === 1

    '' == 0 // true
    // 等同于 Number('') === 0
    // 等同于 0 === 0

    '' == false  // true
    // 等同于 Number('') === Number(false)
    // 等同于 0 === 0

    '1' == true  // true
    // 等同于 Number('1') === Number(true)
    // 等同于 1 === 1

    '\n  123  \t' == 123 // true
    // 因为字符串转为数字时，省略前置和后置的空格
    ```

2. 对象与原始类型值比较

    如果运算子是**对象**，会转为**原始类型**的值，再进行比较。

    「对象」转换成「原始类型」的值，算法是先调用 `valueOf()` 方法；如果返回的还不是**原始类型**，再接着调用 `toString()` 方法，得到**原始类型**，如果都得不到原始类型，则报错。

    得到原始类型后，按上方的第一点「原始类型的值」进行比较。

    ```JavaScript
    [1] == 1 // true
    // 左边等同于 Number([1]) == 1
    // [1].toString() == '1'
    // Number('1') == 1

    [1] == '1' // true
    // 左边等同于 [1].toString() == '1'
    // 右边等同于 Number('1') == 1
    // Number('1') == 1

    [1] == true // true
    // 等同于 Number([1]) == Number(true)
    ```

3. **undefined** 和 **null**

    `undefined` 和 `null` 与其他类型的值比较时，结果都为 `false`，它们互相比较时结果为 `true`，因为都表示「无」，但两者不「严格相等」，因为本质上还是不一样的，一个是未定义，一个是空。

    ```JavaScript
    false == null // false
    false == undefined // false

    0 == null // false
    0 == undefined // false

    undefined == null // true
    undefined === null // false 
    ```

### 布尔运算符

布尔运算符用于将表达式转为**布尔值**，一共包含**四个**运算符。

> 取反运算符：**!**
>
> 且运算符：**&&**
>
> 或运算符：**||**
>
> 三元运算符：**?:**

#### 1. 取反运算符「 ! 」

取反运算符形式上是一个感叹号，用于将布尔值变为相反值，即 `true` 变成 `false`，`false` 变成 `true`。

对于**非布尔值**的数据，取反运算符会自动将其**转为布尔值**。

规则是：以下六个值取反后为 `true`，其他值取反后都为 `false`，因为下面的符号经过 `Boolean()` 方法后都为 `false`。

> `undefined`
>
> `null`
>
> `false`
>
> **0**（包括 **+0** 和 **-0**）
>
> `NaN`
>
> 空字符串 `''`

```JavaScript
!undefined // true
!null // true
!0 // true
!NaN // true
!"" // true

!54 // false
!'hello' // false
![] // false
!{} // false
```

这意味着，「取反运算符」有**转换数据类型**的作用。

如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 `Boolean` 函数的作用相同。这是一种常用的类型转换的写法。

```JavaScript
!!x
// 等同于
Boolean(x)
```

#### 2. 且运算符「 && 」

且运算符「 && 」的运算规则是：

> 如果第一个运算子的布尔值为 `true`，则返回第二个运算子的值（注意是**值**，不是布尔值）；如果第一个运算子的布尔值为 `false`，则直接返回第一个运算子的**值**，且不再对第二个运算子求值。

所以，且运算符「 && 」最终得到的不是布尔值，而是运算子的值。

```JavaScript
1 + 2 && 3 + 6 // 9
1 - 1 && 3 + 6 // 0
```

运算符可以多个连用，这时返回第一个布尔值为 `false` 的表达式的值。

```JavaScript
var x = 1
true && 'foo' && x++ && '' && x++ // ''
x // 2
```

这种跳过第二个运算子的机制，被称为「短路」。有些人喜欢用它取代 `if` 结构，比如下面是一段 `if` 结构的代码，就可以用且运算符改写。

```JavaScript
if (i) {
  doSomething()
}
// 等价于
i && doSomething()
```

#### 3. 或运算符「 || 」

或运算符「 || 」的运算规则是：

> 如果第一个运算子的布尔值为 `true`，则返回第一个运算子的**值**，且**不再**对第二个运算子求值；如果第一个运算子的布尔值为 `false`，则返回第二个运算子的**值**。

```JavaScript
1 + 2 || 3 + 6 // 3
1 - 1 || 3 + 6 // 9
```

或运算符可以多个连用，这时返回第一个布尔值为 `true` 的表达式的值。

```JavaScript
false || 0 || '' || 4 || 'foo' || true // 4
```

**短路规则**对这个运算符也适用。

或运算符常「 || 」用于为一个变量**设置默认值**，如下代码所示：

```JavaScript
function saveText(text) {
  text = text || ''
  // ...
}
// 或者写成
saveText(this.text || '')
```

上面代码表示，如果函数调用时，没有提供参数，则该参数**默认设置**为空字符串。

#### 4. 三元条件运算符「 ?: 」

三元条件运算符用问号「 ? 」和冒号「 : 」，分隔三个表达式，规则如下：

> 如果第一个表达式的布尔值为 `true`，则返回第二个表达式的**值**，否则返回第三个表达式的**值**。


通常来说，三元条件表达式与 `if...else` 语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别：

> `if...else` 是**语句**，没有返回值；三元条件表达式是**表达式**，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用 `if..else`。

```JavaScript
console.log(true ? 'T' : 'F') // T
```

拿上面代码来说，`console.log` 方法的参数必须是一个**表达式**，这时就只能使用三元条件表达式。如果要用 `if...else` 语句，就必须改变整个代码写法了。

---

### 位运算符

位运算符用于直接对二进制位进行计算，一共有 7 个。

> 或运算「 or 」：符号为 **|**，表示若两个二进制位都为 0 ，则结果为 0 ，否则为 1 。
> 
> 与运算「 and 」：符号为 **&**，表示若两个二进制位都为 1 ，则结果为 1 ，否则为 0 。
> 
> 否运算「 not 」：符号为 **~**，表示对一个二进制位取反。
> 
> 异或运算「 xor 」：符号为 **^**，表示若两个二进制位不相同，则结果为 1 ，否则为 0 。
> 
> 左移运算「 left shift 」：符号为 **<<**，详见下文解释。
>
> 右移运算「 right shift 」：符号为 **>>**，详见下文解释。
>
> 带符号位的右移运算「 zero filled right shift 」：符号为 **>>>**，详见下文解释。

    这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。

有一点需要特别注意：

> 位运算符**只对整数起作用**，如果一个运算子不是整数，会**自动转为整数**后再执行。另外，虽然在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是以 32 位带符号的整数进行运算的，并且返回值也是一个 32 位带符号的整数。

#### 1. 或运算「 | 」与 与运算「 & 」

这两种运算比较容易理解，就是逐位比较两个运算子。

「 或运算 」的规则是：

> 两个二进制位之中只要有一个位为 1 ，就返回 1 ，否则返回 0 。

「 与运算 」的规则是：

>两个二进制位之中只要有一个位为 0 ，就返回 0 ，否则返回 1 。

```JavaScript
0 | 3 // 3
0 & 3 // 0
```

上面两个表达式，0和3的二进制形式分别是00和11，所以进行「或运算」会得到11（ 即 3 ），进行「与运算」会得到00（ 即 0 ）。

由于位运算只对**整数**有效，遇到小数时，会将小数部分舍去，只保留整数部分。

所以，将一个小数与 0 进行或运算，等同于对该数去除小数部分，即取整数位。

```JavaScript
i = i | 0
```

上面这行代码的意思，就是将 `i`（不管是整数或小数）转为 32 位整数。

需要注意的是，这种取整方法不适用超过 32 位整数最大值 2147483647 的数。

```JavaScript
2147483649.4 | 0
// -2147483647
```

#### 2. 否运算「 ~ 」

「否运算」的规则是：

> 将每个二进制位都变为相反值（ 0 变为 1，1 变为 0 ）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。

```JavaScript
~ 3 // -4
```

上面表达式对 3 进行「否运算」，得到-4，解析如下：

1. 之所以会有这样的结果，是因为位运算时，JavaScirpt 内部将所有的**运算子**都转为 32 位的二进制整数再进行运算。

    **3** 在 JavaScript 内部是 `00000000000000000000000000000011`，否运算以后得到 `11111111111111111111111111111100`，由于第一位是 1 ，所以这个数是一个负数。

2. JavaScript 内部采用**补码**形式表示负数，即需要将这个数减去 1，再取一次反，然后加上负号，才能得到这个负数对应的 10 进制值：

    这个数减去 1 等于 `11111111111111111111111111111011`，再取一次反得到 `00000000000000000000000000000100`，再加上负号就是 -4。

总的来说，可以简单记忆成：

>「否运算」是将一个数乘以 **-1**，然后减去 **1**。

也可以说成：

> 一个数与自身的「否运算」后的值（取反值）相加，等于 `-1`

若对一个整数连续两次「否运算」，结果是它自身。

因为否运算遇到小数时，也会将小数部分舍去，只保留整数部分，所以两次否运算，能达到取整的效果。

```JavaScript
~~ 6 // 6
~~ 3.233 // 3
```

对于对字符串进行否运算，JavaScript 会先调用 `Number()` 方法进行转换，将字符串转为数值后再进行否运算。对于其他类型的参数，否运算也是先用 `Number()` 方法转为数值，然后再进行处理。

```JavaScript
// 以下例子相当于~Number('011')
~'011'  // -12
~'42 cats' // -1
~'0xcafebabe' // 889275713
~'deadbeef' // -1

// 以下例子相当于~~Number('011')
~~'011'        // 11
~~'42 cats'    // 0
~~'0xcafebabe' // -889275714
~~'deadbeef'   // 0

~~[] // 0
~~NaN // 0
~~null // 0
```

#### 3. 异或运算「 ^ 」

「异或运算」的规则是：

> 在两个二进制位不同时返回1，相同时返回0。

```JavaScript
0 ^ 3 // 3
```

上面表达式中，**0** 的二进制形式是 `00`，**3** 的二进制形式是 `11`，它们每一个二进制位都不同，所以得到 **11**（ 即 **3** ）。

「异或运算」有一个特殊运用，连续对两个数 `a` 和 `b` 进行**三次异或运算**，可以互换它们的值。

```JavaScript
var a = 1, // 二进制：0001
    b = 2  // 二进制：0010

a = a ^ b // 计算结果：a = 0011, b = 0010
b = a ^ b // 计算结果：a = 0011, b = 0001
a = a ^ b // 计算结果：a = 0010, b = 0001

a // 2
b // 1
```

这意味着，使用「异或运算」可以在**不引入临时变量**的前提下，互换两个变量的值。

异或运算也可以用来取整。

```JavaScript
12.9 ^ 0 // 12
```

#### 4. 左移运算符「 << 」

「左移运算符」的规则是：

> 将一个数的二进制值向左移动指定的位数，尾部补 0，即乘以 2 的指定次方（最高位 即**符号位**不参与移动）。

```JavaScript
// 4 的二进制形式为100，
// 左移一位为1000（即十进制的8）
// 相当于乘以2的1次方
4 << 1
// 4 * 2 ^ 1 = 8

-4 << 1
// -4 * 2 ^ 1 = -8
```

上面代码中，**-4** 左移一位得到 **-8**，是因为 **-4** 的二进制形式是 `11111111111111111111111111111100` ，左移一位后得到 `11111111111111111111111111111000` ，该数转为十进制（减去 1 后取反，再加上负号）即为 **-8**。

如果左移 0 位，就相当于将该数值转为 32 位整数，等同于取整，对于正数和负数都有效。

```JavaScript
13.5 << 0 // 13

-13.5 << 0 // -13
```

左移运算符用于二进制数值非常方便。

比如使用左移运算符，将颜色的RGB值转为十六进制值：

```JavaScript
var color = {r: 186, g: 218, b: 85}

// RGB to HEX
// (1 << 24)的作用为保证结果是6位数
var rgb2hex = function(r, g, b) {
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)
    .toString(16)
    .substr(1)
}

rgb2hex(color.r,color.g,color.b)
// "#bada55"
```

#### 5. 右移运算符「 >> 」

「右移运算符」的规则是：

> 将一个数的二进制值向右移动指定的位数，头部补 0，即除以 2 的指定次方（最高位即符号位不参与移动）。

```JavaScript
4 >> 1
// 2
/*
// 因为4的二进制形式为00000000000000000000000000000100，
// 右移一位得到00000000000000000000000000000010，
// 即为十进制的2
*/

-4 >> 1
// -2
/*
// 因为-4的二进制形式为11111111111111111111111111111100，
// 右移一位，头部补1，得到11111111111111111111111111111110,
// 即为十进制的-2
*/

5 >> 1
// 相当于 5 / 2 = 2

21 >> 2
// 相当于 21 / 4 = 5

21 >> 3
// 相当于 21 / 8 = 2

21 >> 4
// 相当于 21 / 16 = 1
```

#### 6. 带符号位的右移运算符 「 >>> 」

「带符号位的右移运算符」的规则是：

> 将一个数的二进制形式向右移动，包括符号位也参与移动，头部补 0。所以，该运算**总是得到正值**。对于正数，该运算的结果与右移运算符「 >> 」完全一致，区别主要在于**负数**。

```JavaScript
4 >>> 1
// 2

-4 >>> 1
// 2147483646
/*
// 因为-4的二进制形式为11111111111111111111111111111100，
// 带符号位的右移一位，得到01111111111111111111111111111110，
// 即为十进制的2147483646。
*/
```

这个运算实际上将一个值转为 32 位无符号整数。

用该算符，可以查看一个负数（或正数，在前头补 0 就好）在内部的存储形式

```JavaScript
(-1 >>> 0).toString(2)
// 11111111111111111111111111111111
```

上面代码表示，**-1** 作为 32 位整数时，内部的储存形式使用**无符号整数格式**解读，值为 4294967295（ 即(2 ^ 32) - 1，等于 `11111111111111111111111111111111`）。

---

### 开关作用

个人认为这是位运算符中比较有意思的一块~ 其可以用作设置对象属性的开关。

什么意思呢？

首先我们假设我们现在有个 4 个开关，每个开关都是一个变量。那么可以一个四位的二进制数，每个开关对应一个进制位。

我们设置 **A**、**B**、**C**、**D** 四个开关，每个开关分别占有一个二进制位。

```JavaScript
var switchA = 1 // 0001
var switchB = 2 // 0010
var switchC = 4 // 0100
var switchD = 8 // 1000
```

然后我们就可以用「与运算」去检验当前设置是否打开了指定开关。

```JavaScript
var flags = 5 // 二进制的0101

if (flags & switchC) {
  // ...
}
// 5 & 4 -> 0101 & 0100 -> 0100 -> true
```

上面只能检测一个开关是否打开，如果我们需要检测是否打开多个开关，应该怎么办呢？此时，我们需要一个**掩码**。

假设我们现在需要打开 **A**、**B**、**D** 开关，此时设置一个掩码

```JavaScript
var mask = switchA | switchB | switchD
// 0001 | 0010 | 1000 -> 1011（ 此时掩码的值为 1011 ）
```

我们有了掩码，就可以利用「或运算」来打开的**需要打开**的开关。

```JavaScript
// flags = 5 = 0101
// mask = 11 = 1011
flags = flags | mask
// falsg = 1111 保留了已经打开的开关，也打开了需要打开的开关
```

「与运算」可以**关闭**所有与**不需要打开**的开关。

```JavaScript
// flags = 5 = 0101
// mask = 11 = 1011
flags = flags & mask
// flags = 0001 关闭了不需要打开的开关
```

判断是否打开了指定的开关

```JavaScript
if (flags & mask == maks) {
  // 指定开关已经打开
}
```

---

### 其他运算符

#### 1. void 运算符

> 执行一个表达式，然后返回 `undefined`。

```JavaScript
void 0 // undefined
void(0) // undefined
```

因为 void 运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，void 4 + 7实际上等同于(void 4) + 7。所以建议采用后一种形式。

这个运算符可以用于防止网页进行跳转，在 `a` 标签的 `href` 或者 `onClick()` 方法中使其中的内容返回的是 `undefined` 可以防止网页进行跳转。

```html
<a href="javascript:void(window.open('http://example.com/'))">
  点击打开新窗口
</a>

<!-- 或者 -->

<a href="http://example.com" onclick="f()">文字</a> 
<script>
  function f() {
    // some code
    return false
  }
</script>
<!-- 函数 f 必须返回 false -->
<!-- 或者说 onclick 事件必须返回 false，否则会引起浏览器跳转到 example.com。 -->

<!-- 也可以写成 -->

<a href="http://example.com" onclick="f();return false;">文字</a>

<!-- void 可以代替上面两种方法 -->

<a href="javascript: void(f())">文字</a>
```

就比如下面的代码会提交表单，但是不会产生页面跳转：

```html
<a href="javascript: void(document.form.submit())">文字</a>
```

#### 2. 逗号运算符

> 对两个表达式求值，并返回最后一个表达式的值。

```javascript
'a', 'b' // "b"

var x = 0
var y = (x++, 10)
x // 1
y // 10
```

---


### 小技巧

`Number(x)` 简化为 `+ x`

`String(x)` 简化为 `x + ''`

`Boolean(x)` 简化为 `!! x`

`parseInt(x)` 简化为 `x | 0` 或 `x ^ 0` 或 `x << 0` 或 `~~ x` （ 使用「否运算 ~」取整，是所有取整方法中最快的一种 ）

交换两个变量的值

```JavaScript
var a = 10
var b = 99

a ^= b, b ^= a, a ^= b

a // 99
b // 10
```