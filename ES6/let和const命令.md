### let 命令

ES6 新增了 `let` 命令，用来声明变量。它的用法类似于 `var`，但是所声明的变量，只在 `let` 命令所在的代码块内有效。

```javascript
{
  let a = 10
  var b = 1
}
a // ReferenceError: a is not defined.
b // 1
```

上面代码在代码块之中，分别用 `let` 和 `var` 声明了两个变量。然后在代码块之外调用这两个变量，结果 `let` 声明的变量报错，`var` 声明的变量返回了正确的值。这表明，`let` 声明的变量只在它所在的代码块有效。

`for` 循环的计数器，就很合适使用 `let` 命令，因为计数器 `i` 只在 `for` 循环体内有效，在循环体外引用就会报错：

```javascript
for (let i = 0; i < 10; i++) {
  /* code */
}

console.log(i) // ReferenceError: i is not defined
```

利用 `let` 这个特性，我们可以解决一些小问题，比如：

```javascript
var a = []
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[6]() // 10
```

上面的 `for` 循环声明的是用 `var` 声明的一个变量 `i`，因为 `for` 语句中的 `var` 声明变量后，变量的作用于在父级，相当于：

```javascript
var i
for (i = 0; i < 10; i++) {
  /* code */
}
```

所以导致数组 `a` 中的每一个方法输出的都是全局变量的 `i`；如果使用了 `let` 去声明变量，此时变量 `i` 作用于在 `for` 语句的代码块中，所以这时候 `i` 仅在块级作用域内有效：

```javascript
var a = []
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[6]() // 6
```

为了满足我的好奇心，我将上面用 `let` 声明的代码用 `Babel` 转换了一下：

```javascript
"use strict";

var a = [];

var _loop = function _loop(i) {
  a[i] = function () {
    console.log(i);
  };
};

for (var i = 0; i < 10; i++) {
  _loop(i);
}
a[6]();
```

就一目了然啦，然鹅对使用 `var` 声明的 `for` 循环我发现没有变化 😀 因为不需要变。

另外，`for` 循环还有一个特别之处，前面我也说了，就是**设置循环变量**的那部分是一个「父作用域」，而**循环体内部**是一个单独的「子作用域」；来，我们举个栗子 🌰 ：

```javascript
for (let i = 0; i < 3; i++) {
  let i = 'abc'
  console.log(i)
}
// abc
// abc
// abc
```

上面代码输出了上次 `abc` 表明函数内部声明的变量没有覆盖循环中设置的变量，说明函数内部的变量 `i` 与循环变量 `i` 不在同一个作用域，有各自单独的作用域。


说到这里我要说一说为什么在 `for` 循环中使用 `var` 会泄露成全局变量以及使用 `let` 就不会：

前面说到 `for` 循环中的**设置初始值**的语句，也就是括号中的语句，是声明在父级作用域的，实际上这个解释是被没有办法解释为什么使用 `let` 声明的话就不会成为全局变量。后来查了许多资料，最后再知乎上看到了一句评论瞬间让我方便理解了：「 `for` 循环中括号是一个块级作用域，花括号是另一个块级作用域，括号作用于是包着花括号的作用域的」这样就可以解释的通了：

当我们使用在 `for` 循环中使用 `var` 声明初始值的时候，可以理解成在括号块级作用域声明了一个变量，在其子块级作用域是肯定能读到的，但是因为是 `var` 声明的变量，`for` 循环的块级作用域相当处于全局环境，这时候相当于在全局环境中声明了一个变量，所以在 `for` 循环之后还能够在全局环境中读取到该变量的内容。

如果我们使用 `let` 声明初始值的话，相当于这个变量绑定了括号以及花括号两个作用域，这两个地方都能够读到该变量，但是不会泄露到全局环境，因为处于括号的块级作用域；此时，如果我们在花括号作用域中声明了一个相同名称的变量，不会报错是因为两个变量声明的块级作用域不同，各自读各自的变量各不冲突。

以上是我个人的理解，如果你认为有错误，欢迎 [issue](https://github.com/LBinin/LearnJS/issues) 我 😆

---

### let 中几个需要注意的地方

1. 不存在变量提升

    `var` 命令会发生「变量提升」现象，即变量可以在声明之前使用，值为 `undefined`。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。

    为了纠正这种现象，`let` 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错：

    ```javascript
    // var 的情况
    console.log(foo) // 输出undefined
    var foo = 2

    // let 的情况
    console.log(bar) // 报错ReferenceError
    let bar = 2
    ```

    上面代码中，变量 `foo` 用 `var` 命令声明，会发生变量提升，即脚本开始运行时，变量 `foo` 已经存在了，但是没有值，所以会输出 `undefined`。变量 `bar` 用 `let` 命令声明，不会发生变量提升。这表示在声明它之前，变量 `bar` 是不存在的，这时如果用到它，就会抛出一个错误。

2. 暂时性死区

    > 在代码块内，使用 let 命令声明变量「之前」，该变量都是**不可用**的。这在语法上，称为「暂时性死区」（ temporal dead zone，简称 TDZ ）。

    ES6 明确规定，如果区块中存在 `let` 和 `const` 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

    ```javascript
    if (true) {
        // TDZ开始
        tmp = 'abc' // ReferenceError
        console.log(tmp) // ReferenceError

        let tmp // TDZ结束
        console.log(tmp) // undefined

        tmp = 123
        console.log(tmp) // 123
    }
    ```

    咱们再来一场捉迷藏：

    ```javascript
    function bar(x = y, y = 2) {
        return [x, y]
    }

    bar() // 报错
    ```

    上面代码中，调用 `bar` 函数之所以报错（ 某些实现可能不报错 ），是因为参数 `x` 默认值等于另一个参数 `y` ，而此时 `y` 还没有声明，属于「死区」。如果 `y` 的默认值是 `x` ，就不会报错，因为此时 `x` 已经声明了：

    ```javascript
    function bar(x = 2, y = x) {
        return [x, y]
    }
    bar() // [2, 2]
    ```

3. 不允许重复声明

    `let` 不允许在相同作用域内，重复声明同一个变量。相当于使用 `let` **声明前后**都不允许有声明同一个变量的语句的存在（ 不论 `let` 或者 `var` ）

    ```javascript
    var a = 10
    let a = 1
    // 报错

    let a = 10
    var a = 1
    // 报错

    let a = 10
    let a = 1
    // 报错
    ```

    因此，不能在函数内部重新用 `let` 声明参数：

    ```javascript
    function func(arg) {
        let arg; // 报错
    }
    ```

---

### 块级作用域

ES5 只有「全局作用域」和「函数作用域」，没有「块级作用域」，这带来很多不合理的场景。

先来说说我们为什么需要块级作用域吧：

1. 第一种场景，内层变量可能会覆盖外层变量：

    ```javascript
    var tmp = new Date()

    function f() {
        console.log(tmp)
        if (false) {
            var tmp = 'hello world'
        }
    }

    f() // undefined
    ```

    上面代码因为存在变量提升，`tmp` 被提升到函数顶部，所以输出的是 `undefined`，导致内层的 `tmp` 变量覆盖了外层的 `tmp` 变量。

2. 第二种场景，用来计数的循环变量泄露为全局变量：

    ```javascript
    var s = 'hello'

    for (var i = 0; i < s.length; i++) {
        console.log(s[i])
    }

    console.log(i) // 5
    ```

    上面代码中，变量 `i` 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

接下来，我们来说说它的特性：

ES6 是允许块级作用域的任意嵌套的，并且「外层作用域」无法读取「内层作用域」的变量，但是「内层作用域」不仅可以读取「外层作用域」的变量，还能声明同名的变量（ 这里说的变量都是使用 `let` 声明的 ）。

此外，由于块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（ IIFE ）不再必要了：

```javascript
// IIFE 写法
(function () {
  var tmp = ...
  ...
}())

// 块级作用域写法
{
  let tmp = ...
  ...
}
```

### const 命令

`const` 声明一个只读的常量。除了声明的是常量以外，其他的特点和 `let` 一样，包括：

- 只在声明所在的块级作用域内有效。
- 不存在变量提升。
- 同样存在暂时性死区。
- 不可重复声明。

**本质**

> `const` 实际上保证的并不是「变量的值」不得改动，而是变量指向的那个「内存地址」不得改动。

对于简单类型的数据（ 数值、字符串、布尔值 ），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（ 主要是对象和数组 ），变量指向的内存地址，保存的只是一个指针，`const` 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

```javascript
const foo = {}

// 为 foo 添加一个属性，可以成功
foo.prop = 123
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {} // TypeError: "foo" is read-only
```

上面代码中，常量 `foo` 储存的是一个「地址」，这个地址指向一个**对象**。不可变的只是这个地址，即不能把 `foo` 指向「另一个地址」，但地址指向的对象本身是**可变**的，所以依然可以为其添加新属性。

如果真的想将对象冻结（ 无法添加、删除、修改属性 ），应该使用 `Object.freeze()` 方法。

---

### ES6 声明变量的六种方法

BTW，ES5 只有两种声明变量的方法，ES6 声明变量的六种方法，：`var` 命令和 `function` 命令。ES6 除了添加 `let` 和 `const` 命令，后面章节还会提到，另外两种声明变量的方法：`import` 命令和 `class` 命令。所以，ES6 一共有 6 种声明变量的方法。

---

### 顶层对象的属性

```javascript
window.a = 1
a // 1

a = 2
window.a // 2
```

上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。ES5 之中，顶层对象的属性与全局变量是等价的。

ES6 为了改变顶层对象的属性与全局变量是等价的这一点，一方面规定，为了保持兼容性，`var` 命令和 `function` 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let` 命令、`const` 命令、`class` 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

```javascript
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```

上面代码中，全局变量 `a` 由 `var` 命令声明，所以它是顶层对象的属性；全局变量 `b` 由 `let` 命令声明，所以它不是顶层对象的属性，返回 `undefined`。