### 算术运算符

JavaScript 提供 **9** 个算术运算符，用来完成基本的算术运算。

> 加法运算符（Addition）： **x + y**
> 
> 减法运算符（Subtraction）： **x - y**
> 
> 乘法运算符（Multiplication）： **x * y**
> 
> 除法运算符（Division）： **x / y**
> 
> 余数运算符（Remainder）： **x % y**
> 
> 自增运算符（Increment）： **++x** 或者 **x++**
> 
> 自减运算符（Decrement）： **--x** 或者 **x--**
> 
> 数值运算符（Convert to number）： **+x**
> 
> 负数值运算符（Negate）： **-x**


#### 1. 「 **+** 」加法运算符、数值运算符

加法运算符（ **+** ）是最常见的运算符之一，但是使用规则却相对复杂。因为在 JavaScript 语言里面，这个运算符可以表示两种运算，既可以处理**算术的加法**，也可以用作**字符串连接**，它们都写成 `+`。

它的算法步骤为：

1. 如果运算子是**对象**，先自动转成**原始类型**的值（即先执行该对象的 `valueOf` 方法，如果结果不是原始类型的值，再执行 `toString` 方法；如果对象是 `Date` 实例，则先执行 `toString` 方法）。
 
2. 两个运算子都是**原始类型**的值，**只要**有一个运算子是「**字符串**」，则两个运算子都转为字符串，执行字符串**连接**运算，返回的是 String 类型。

3. 如果两边都没有字符串，则两个运算子都转为数值（ Number ），然后执行加法运算，返回的是 **Number** 类型。

这种由于参数不同，而改变自身行为的现象，叫做「**重载**」（overload）。由于加法运算符是**运行时**决定到底执行那种运算，使用的时候必须很小心。

```JavaScript
// 加法
1 + 1 // 2
true + true // 2 Number(true) == 1
1 + true // 2

// 字符串连接
'1' + '1' // "11"
'1.1' + '1.1' // "1.11.1"

// 字符串与其他类型
'1' + {foo: 'bar'} // "1[object Object]"
'1' + 1 // "11"
'1' + true // "1true"
'1' + [1] // "11"

// 运算结果由于字符串的位置不同而不同
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
```

**加法**运算符一定有左右两个运算子。

如果加号只有**右边**一个运算子，就是另一个运算符，叫做「**数值运算符**」（ Convert to number ）。

> 数值运算符用于返回右边运算子的**数值形式**。

```JavaScript
+ - 3   // 等同于 +(-3)
+ 1 + 2 // 等同于 +(1 + 2)
+ '1'   // 1
```

如果加号只有**左边**一个运算子，就会报错 😑。

```JavaScript
1 +
// SyntaxError: Unexpected end of input
```

前面说到了加法运算符有「**重载**」的情况，但是除了 **加号**，其他运算符（ 如 **减法**、**除法**和**乘法** ）都没有重载的情况。

这些运算符的规则是：所有的运算子一律转化为**数值**（ Number ）后，在进行数学运算。

```JavaScript
1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

综上所述，由于**加法**运算符与其他算术运算符存在「重载」这种差异，所以会导致一些意想不到的结果，使用的时候要小心。

```JavaScript
var now = new Date()
typeof (now + 1) // "string"
typeof (now - 1) // "number"
```

**解析**：

**遇到加号**，因为左运算子 `now` 是**对象**，而且是 `Date` 对象，先调用其 `toString()` 方法得到原始数据类型 `String` （ 如：`Mon Jan 01 2018 01:49:43 GMT+0800 (CST)` ），然后进行字符串的连接，最后的结果还是字符串类型；

**遇到减号**，不存在重载的问题，一律转换为 **Number** 类型（如：`1514742583083`），然后进行数学运算，所以最后返回的结果是数值类型。


#### 2. 「 **-** 」减法运算符、负数值运算符

减法运算符（-）是一个二元运算符（需要两个操作数），运算的规则也在上面的「+」运算符中介绍过了，这里就不再赘述，主要来说一下「**负数值运算符**」。

「**负数值运算符**」它是一元运算符（只需要一个操作数）。也同样具有将一个值转为**数值**的功能，只不过得到的**值正负相反**，注意是相反，而不是一定得到的是负数。连用两个负数值运算符，等同于数值运算符。

```JavaScript
- '123'     // -123
- '-123'    // 123
- (- '123') // 123
```


#### 3. 「 **%** 」余数运算符

> 余数运算符（ **%** ）返回前一个运算子被后一个运算子除，所得的余数。

需要注意的是，运算结果的正负号由第一个运算子的正负号决定。

```JavaScript
-1 % 2 // -1
1 % -2 // 1
```

如果需要求负数的余数的话，由于规定余数大于 0，所以比如：-9 % 4 应该要等于 3，但是 JavaScript 会把 -9 前面的负号当做结果的符号。就是 先运算 9 % 4 等于 1，然后用第一个运算子的符号决定结果的正负，得到 -1。

```JavaScript
/* 求余数 */
function remainder(x, y) {
  if (x < 0) return x % y + y
  else return x % y
}
remainder(-9, 4) // 3

/* 单纯判断是否为奇数 */
function isOdd(n) {
  return Math.abs(n % 2) === 1
}
isOdd(-5) // true
isOdd(-4) // false
```

---

### 赋值运算符

除了最常见的赋值运算符「=」等号赋值，JavaScript 还提供其他 11 个复合的赋值运算符。

```JavaScript
x += y // 等同于 x = x + y
x -= y // 等同于 x = x - y
x *= y // 等同于 x = x * y
x /= y // 等同于 x = x / y
x %= y // 等同于 x = x % y
x >>= y // 等同于 x = x >> y
x <<= y // 等同于 x = x << y
x >>>= y // 等同于 x = x >>> y
x &= y // 等同于 x = x & y
x |= y // 等同于 x = x | y
x ^= y // 等同于 x = x ^ y
```

---

### 比较运算符

> 比较运算符用于比较两个值，然后返回一个**布尔值**，表示是否满足比较条件。
> 
> 比较运算符可以比较**各种类型**的值，不仅仅是数值。

JavaScript 一共提供了 8 个比较运算符。

> == 相等
>
> === 严格相等
>
> != 不相等
>
> !== 严格不相等
>
> < 小于
>
> <= 小于或等于
>
> \> 大于
>
> \>= 大于或等于

「相等运算符」和「严格相等运算符」，有自己的比较算法，详情见 [严格相等运算符](#严格相等运算符) 和 [相等运算符](#相等运算符)，实例： [为什么 [1] == [1] 为 false ?](https://github.com/LBinin/LearnJS/blob/master/%08%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86.md#1-%E4%B8%BA%E4%BB%80%E4%B9%88-1--1-%E4%B8%BA-false-) 。其他六个比较运算符的算法如下：

    1. 如果两个运算子都是字符串，则按照字典顺序比较（ 实际上是比较 Unicode 码点 ）。
     
    2. 否则，将两个运算子都转成数值，再进行比较（ 等同于调用 Number 函数 ）。

#### 1. 字符串的比较

JavaScript 引擎内部首先比较首字符的 **Unicode** 码点，如果相等，再比较第二个字符的 **Unicode** 码点，以此类推。有关 Unicode 的介绍，可以阅读一下阮老师的 [Unicode与JavaScript详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html) 这篇文章。

```JavaScript
/* 获取字符的 Unicode 码点 */
parseInt('c'.charCodeAt(0)) // 99

/* 获取字符的十六进制 Unicode */
'\\u' + parseInt('c'.charCodeAt(0)).toString(16) // '\u63'
```

```JavaScript
'cat' > 'dog' // false
```

第一个字符 `c` 的码点（ 99 ）小于 `d` 的码点（ 100 ），所以 `cat` 相比之下比 `dog` 小。


```JavaScript
'cat' < 'catalog' // true 
```

前三个字母 `cat` 的码点相同，由于第一个 `cat` 没有第四位字符，右边的 `catalog` 的第四个字符 `a` 的码点（ 99 ）相当于大于 **0**，所以比较的结果是 `catalog` 大。

```JavaScript
'cat' > 'Cat' // true 
```

小写的 `c` 的 Unicode 码点（99）大于大写的 `C` 的 Unicode 码点（67），所以返回true。

```JavaScript
'大' > '小' // false
```
上面代码中，`大` 的 Unicode 码点是 22823，`小` 是23567，因此返回 `false`。

#### 2. 原始类型的比较

这里先讨论**比较运算**，关于「相等运算符」、「严格相等运算符」的规则之后再讨论。

前面说到除了**两个相等运算符**以及运算子都是**字符串**的情况下，其他情况都是将两边的运算子都转换成数值（ Number ）后再进行数值比较

```JavaScript
5 > '4'       // true 相当于 5 > Number('4') -> 5 > 4
true > false  // true 相当于 Number(true) > Number(false) -> 1 > 0
2 > true      // true 相当于 2 > Number(true) -> 2 > 1
```

有一个特殊情况，即任何值（包括 `NaN` 本身）与 `NaN` 比较，返回的都是 `false`。

```JavaScript
1 > NaN // false
1 <= NaN // false
'1' > NaN // false
'1' <= NaN // false
NaN > NaN // false
NaN <= NaN // false
```

#### 3. 对象的比较

如果运算子是**对象**，会转为**原始类型**的值，再进行比较。

对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法。两个对象之间的比较也是如此。详细解释见「数据类型的转换」笔记。

```JavaScript
var x = [2]
x > '11' // true 相当于 [2].valueOf().toString() > '11' -> '2' > '11'

x.valueOf = function () { return '1' }
x > '11' // false 相当于 [2].valueOf() > '11' -> '1' > '11'
```

### 严格相等运算符

JavaScript 提供两种相等运算符：`==` 和 `===`。

简单说，它们的区别是相等运算符（ `==` ）比较两个**值是否相等**，严格相等运算符（ `===` ）比较它们是否为「同类型相等的值」。如果两个值不是同一类型，严格相等运算符（ `===` ）直接返回 `false`，而相等运算符（ `==` ）会将它们**转化成同一个类型**，再用严格相等运算符进行比较。

严格相等运算符的规则如下：

1. 不同类型的值

    如果两个值的类型不同，直接返回 `false`。

2. 同一类型的原始类型值

    同一类型的**原始类型**的值（数值、字符串、布尔值）比较时，值相同就返回 `true`，值不同就返回 `false`。

    需要注意的是，`NaN` 与任何值都不相等（包括自身）。另外，**正0** 等于 **负0**。

    ```JavaScript
    1 === 0x1 // true
    NaN === NaN  // false
    +0 === -0 // true
    ```

3. 同一类型的复合类型值

    同一类型的**复合类型**的值（对象、数组、函数）比较时，不是比较它们的**值是否相等**，而是比较它们是否指向同一个对象（ 是否为同一引用 ）。

    ```JavaScript
    {} === {} // false
    [] === [] // false
    (function (){} === function (){}) // false

    /* 如果两个变量引用同一个对象，则它们相等 */
    var v1 = {}
    var v2 = v1
    v1 === v2 // true
    ```

    注意，对于两个对象的比较，「严格相等运算符」比较的是**地址**，而「大于或小于运算符」比较的是**值**。

    ```JavaScript
    new Date() > new Date() // false
    new Date() < new Date() // false
    new Date() === new Date() // false
    (new Date()).valueOf() === (new Date()).valueOf() // true
    ```

    上面的四个表达式，前两个比较的是值，因为值相同；所以返回的是 `false`，第三个比较的是地址，所以返回 `false`；最后一个是比较两个对象的值是否相等，不是比较的地址，所以返回是 `true`。

4. **undefined** 和 **null**

    `undefined` 和 `null` 与**自身**严格相等，但是**两者**不严格相等。

    ```JavaScript
    undefined === undefined // true
    null === null // true
    ```

### 相等运算符

「相等运算符」比较**相同类型**的数据时，与严格相等运算符的规则完全一样。

比较**不同类型**的数据时，相等运算符会先将数据进行**类型转换**，然后再用严格相等运算符比较。类型转换规则如下。

1. 原始类型的值

    **原始类型**的数据会转换成**数值**（ Number ）类型再进行比较。

    ```JavaScript
    1 == true // true
    // 等同于 1 === 1

    0 == false // true
    // 等同于 0 === 0

    2 == true // false
    // 等同于 2 === 1

    2 == false // false
    // 等同于 2 === 0

    'true' == true // false
    // 等同于 Number('true') === Number(true)
    // 等同于 NaN === 1

    '' == 0 // true
    // 等同于 Number('') === 0
    // 等同于 0 === 0

    '' == false  // true
    // 等同于 Number('') === Number(false)
    // 等同于 0 === 0

    '1' == true  // true
    // 等同于 Number('1') === Number(true)
    // 等同于 1 === 1

    '\n  123  \t' == 123 // true
    // 因为字符串转为数字时，省略前置和后置的空格
    ```

2. 对象与原始类型值比较

    如果运算子是**对象**，会转为**原始类型**的值，再进行比较。

    「对象」转换成「原始类型」的值，算法是先调用 `valueOf()` 方法；如果返回的还不是**原始类型**，再接着调用 `toString()` 方法，得到**原始类型**，如果都得不到原始类型，则报错。

    得到原始类型后，按上方的第一点「原始类型的值」进行比较。

    ```JavaScript
    [1] == 1 // true
    // 左边等同于 Number([1]) == 1
    // [1].toString() == '1'
    // Number('1') == 1

    [1] == '1' // true
    // 左边等同于 [1].toString() == '1'
    // 右边等同于 Number('1') == 1
    // Number('1') == 1

    [1] == true // true
    // 等同于 Number([1]) == Number(true)
    ```

3. **undefined** 和 **null**

    `undefined` 和 `null` 与其他类型的值比较时，结果都为 `false`，它们互相比较时结果为 `true`，因为都表示「无」，但两者不「严格相等」，因为本质上还是不一样的，一个是未定义，一个是空。

    ```JavaScript
    false == null // false
    false == undefined // false

    0 == null // false
    0 == undefined // false

    undefined == null // true
    undefined === null // false 
    ```

### 布尔运算符

布尔运算符用于将表达式转为**布尔值**，一共包含**四个**运算符。

> 取反运算符：**!**
>
> 且运算符：**&&**
>
> 或运算符：**||**
>
> 三元运算符：**?:**

#### 1. 取反运算符「 ! 」

取反运算符形式上是一个感叹号，用于将布尔值变为相反值，即 `true` 变成 `false`，`false` 变成 `true`。

对于**非布尔值**的数据，取反运算符会自动将其**转为布尔值**。

规则是：以下六个值取反后为 `true`，其他值取反后都为 `false`，因为下面的符号经过 `Boolean()` 方法后都为 `false`。

> `undefined`
>
> `null`
>
> `false`
>
> **0**（包括 **+0** 和 **-0**）
>
> `NaN`
>
> 空字符串 `''`

```JavaScript
!undefined // true
!null // true
!0 // true
!NaN // true
!"" // true

!54 // false
!'hello' // false
![] // false
!{} // false
```

这意味着，「取反运算符」有**转换数据类型**的作用。

如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 `Boolean` 函数的作用相同。这是一种常用的类型转换的写法。

```JavaScript
!!x
// 等同于
Boolean(x)
```

#### 4. 且运算符「 && 」

且运算符「 && 」的运算规则是：

> 如果第一个运算子的布尔值为 `true`，则返回第二个运算子的值（注意是**值**，不是布尔值）；如果第一个运算子的布尔值为 `false`，则直接返回第一个运算子的**值**，且不再对第二个运算子求值。

所以，且运算符「 && 」最终得到的不是布尔值，而是运算子的

```JavaScript
1 + 2 && 3 + 6 // 9
1 - 1 && 3 + 6 // 0
```

---

`Number(x)` 简化为 `+ x`

`String(x)` 简化为 `x + ''`

`Boolean(x)` 简化为 `!! x`