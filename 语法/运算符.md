### 算术运算符

JavaScript 提供 **9** 个算术运算符，用来完成基本的算术运算。

> 加法运算符（Addition）： **x + y**
> 
> 减法运算符（Subtraction）： **x - y**
> 
> 乘法运算符（Multiplication）： **x * y**
> 
> 除法运算符（Division）： **x / y**
> 
> 余数运算符（Remainder）： **x % y**
> 
> 自增运算符（Increment）： **++x** 或者 **x++**
> 
> 自减运算符（Decrement）： **--x** 或者 **x--**
> 
> 数值运算符（Convert to number）： **+x**
> 
> 负数值运算符（Negate）： **-x**


#### 1. 「 **+** 」加法运算符、数值运算符

加法运算符（ **+** ）是最常见的运算符之一，但是使用规则却相对复杂。因为在 JavaScript 语言里面，这个运算符可以表示两种运算，既可以处理**算术的加法**，也可以用作**字符串连接**，它们都写成 `+`。

它的算法步骤为：

1. 如果运算子是**对象**，先自动转成**原始类型**的值（即先执行该对象的 `valueOf` 方法，如果结果不是原始类型的值，再执行 `toString` 方法；如果对象是 `Date` 实例，则先执行 `toString` 方法）。
 
2. 两个运算子都是**原始类型**的值，**只要**有一个运算子是「**字符串**」，则两个运算子都转为字符串，执行字符串**连接**运算，返回的是 String 类型。

3. 如果两边都没有字符串，则两个运算子都转为数值（ Number ），然后执行加法运算，返回的是 **Number** 类型。

这种由于参数不同，而改变自身行为的现象，叫做「**重载**」（overload）。由于加法运算符是**运行时**决定到底执行那种运算，使用的时候必须很小心。

```JavaScript
// 加法
1 + 1 // 2
true + true // 2 Number(true) == 1
1 + true // 2

// 字符串连接
'1' + '1' // "11"
'1.1' + '1.1' // "1.11.1"

// 字符串与其他类型
'1' + {foo: 'bar'} // "1[object Object]"
'1' + 1 // "11"
'1' + true // "1true"
'1' + [1] // "11"

// 运算结果由于字符串的位置不同而不同
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
```

**加法**运算符一定有左右两个运算子。

如果加号只有**右边**一个运算子，就是另一个运算符，叫做「**数值运算符**」（ Convert to number ）。

> 数值运算符用于返回右边运算子的**数值形式**。

```JavaScript
+ - 3   // 等同于 +(-3)
+ 1 + 2 // 等同于 +(1 + 2)
+ '1'   // 1
```

如果加号只有**左边**一个运算子，就会报错 😑。

```JavaScript
1 +
// SyntaxError: Unexpected end of input
```

前面说到了加法运算符有「**重载**」的情况，但是除了 **加号**，其他运算符（ 如 **减法**、**除法**和**乘法** ）都没有重载的情况。

这些运算符的规则是：所有的运算子一律转化为**数值**（ Number ）后，在进行数学运算。

```JavaScript
1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

综上所述，由于**加法**运算符与其他算术运算符存在「重载」这种差异，所以会导致一些意想不到的结果，使用的时候要小心。

```JavaScript
var now = new Date()
typeof (now + 1) // "string"
typeof (now - 1) // "number"
```

**解析**：

**遇到加号**，因为左运算子 `now` 是**对象**，而且是 `Date` 对象，先调用其 `toString()` 方法得到原始数据类型 `String` （ 如：`Mon Jan 01 2018 01:49:43 GMT+0800 (CST)` ），然后进行字符串的连接，最后的结果还是字符串类型；

**遇到减号**，不存在重载的问题，一律转换为 **Number** 类型（如：`1514742583083`），然后进行数学运算，所以最后返回的结果是数值类型。


#### 2. 「 **-** 」减法运算符、负数值运算符

减法运算符（-）是一个二元运算符（需要两个操作数），运算的规则也在上面的「+」运算符中介绍过了，这里就不再赘述，主要来说一下「**负数值运算符**」。

「**负数值运算符**」它是一元运算符（只需要一个操作数）。也同样具有将一个值转为**数值**的功能，只不过得到的**值正负相反**，注意是相反，而不是一定得到的是负数。连用两个负数值运算符，等同于数值运算符。

```JavaScript
- '123'     // -123
- '-123'    // 123
- (- '123') // 123
```


#### 3. 「 **%** 」余数运算符

> 余数运算符（ **%** ）返回前一个运算子被后一个运算子除，所得的余数。

需要注意的是，运算结果的正负号由第一个运算子的正负号决定。

```JavaScript
-1 % 2 // -1
1 % -2 // 1
```

如果需要求负数的余数的话，由于规定余数大于 0，所以比如：-9 % 4 应该要等于 3，但是 JavaScript 会把 -9 前面的负号当做结果的符号。就是 先运算 9 % 4 等于 1，然后用第一个运算子的符号决定结果的正负，得到 -1。

```JavaScript
/* 求余数 */
function remainder(x, y) {
  if (x < 0) return x % y + y
  else return x % y
}
remainder(-9, 4) // 3

/* 单纯判断是否为奇数 */
function isOdd(n) {
  return Math.abs(n % 2) === 1
}
isOdd(-5) // true
isOdd(-4) // false
```

---

### 赋值运算符

除了最常见的赋值运算符「=」等号赋值，JavaScript 还提供其他 11 个复合的赋值运算符。

```JavaScript
x += y // 等同于 x = x + y
x -= y // 等同于 x = x - y
x *= y // 等同于 x = x * y
x /= y // 等同于 x = x / y
x %= y // 等同于 x = x % y
x >>= y // 等同于 x = x >> y
x <<= y // 等同于 x = x << y
x >>>= y // 等同于 x = x >>> y
x &= y // 等同于 x = x & y
x |= y // 等同于 x = x | y
x ^= y // 等同于 x = x ^ y
```

---

### 比较运算符

> 比较运算符用于比较两个值，然后返回一个**布尔值**，表示是否满足比较条件。
> 
> 比较运算符可以比较**各种类型**的值，不仅仅是数值。

JavaScript 一共提供了 8 个比较运算符。

> == 相等
>
> === 严格相等
>
> != 不相等
>
> !== 严格不相等
>
> < 小于
>
> <= 小于或等于
>
> \> 大于
>
> \>= 大于或等于

「相等运算符」和「严格相等运算符」，有自己的比较算法，详情见 [严格相等运算符](#严格相等运算符) 和 [相等运算符](#相等运算符)，实例： [为什么 [1] == [1] 为 false ?](https://github.com/LBinin/LearnJS/blob/master/%08%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86.md#1-%E4%B8%BA%E4%BB%80%E4%B9%88-1--1-%E4%B8%BA-false-) 。其他六个比较运算符的算法如下：

    1. 如果两个运算子都是字符串，则按照字典顺序比较（ 实际上是比较 Unicode 码点 ）。
     
    2. 否则，将两个运算子都转成数值，再进行比较（ 等同于调用 Number 函数 ）。

#### 1. 字符串的比较

JavaScript 引擎内部首先比较首字符的 **Unicode** 码点，如果相等，再比较第二个字符的 **Unicode** 码点，以此类推。

```JavaScript
/* 获取字符的 Unicode 码点 */
parseInt('c'.charCodeAt(0)) // 99

/* 获取字符的十六进制 Unicode */
'\\u' + parseInt('c'.charCodeAt(0)).toString(16) // '\u63'
```

```JavaScript
'cat' > 'dog' // false
```

第一个字符 `c` 的码点（ 99 ）小于 `d` 的码点（ 100 ），所以 `cat` 相比之下比 `dog` 小。


```JavaScript
'cat' < 'catalog' // true 
```

前三个字母 `cat` 的码点相同，由于第一个 `cat` 没有第四位字符，右边的 `catalog` 的第四个字符 `a` 的码点（ 99 ）相当于大于 **0**，所以比较的结果是 `catalog` 大。

```JavaScript
'cat' > 'Cat' // true 
```

小写的 `c` 的 Unicode 码点（99）大于大写的 `C` 的 Unicode 码点（67），所以返回true。

```JavaScript
'大' > '小' // false
```
上面代码中，`大` 的 Unicode 码点是 22823，`小` 是23567，因此返回 `false`。

#### 2. 原始类型的比较

这里先讨论**比较运算**，关于「相等运算符」、「严格相等运算符」的规则之后再讨论。

前面说到除了**两个相等运算符**以及运算子都是**字符串**的情况下，其他情况都是将两边的运算子都转换成数值（ Number ）后再进行数值比较

```JavaScript
5 > '4' // true 相当于 5 > Number('4') -> 5 > 4
true > false // true 相当于 Number(true) > Number(false) -> 1 > 0
2 > true // true 相当于 2 > Number(true) -> 2 > 1

```

#### 3. 对象的比较