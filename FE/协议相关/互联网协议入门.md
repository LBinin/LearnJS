## 概述

### 五层模型

以「五层模型」为例，从最底层开始：

**硬件 -> 实体层 -> 链接层 -> 网络层 -> 传输层 -> 应用层 -> 用户**

每一层都为了要完成自己的功能，需要大家都遵守共同的**规则**，这个规则就是「协议」。

所有层的所有协议**总称**为「互联网协议」。

---

## 实体层

电脑要组网，第一件事要干什么？

当然是先把电脑**连起来**，可以用光缆、电缆、双绞线、无线电波等方式。

把电脑连接起来的物理手段就叫做「实体层」。

它主要**规定**了网络的一些**电气特性**。

**作用**是负责传送 0 和 1 的电信号。

---

## 链接层

拿到了单纯的 0 和 1 没有任何意义，必须规定解读方式：

> 多少个电信号算一组？每个信号位有何意义？

这就是「链接层」的功能，它在**实体层**的上方，确定了 0 和 1 的分组方式。

### 以太网

早期的时候，每家公司都有自己的**电信号分组方式**。逐渐地，一种叫做「以太网」（ Ethernet ）的协议，占据了主导地位。

以太网规定，**一组电信号**构成一个数据包，叫做「帧」（ Frame ）。每一帧分成两个部分：标头（ Head ）和数据（ Data ）。

**标头**：包含数据包的一些说明项，比如发送者、接受者、数据类型等等；其中发送者和接受者的信息用的是 **MAC** 地址进行标识。

**数据**：则是数据包的具体内容。

**长度**：「标头」的长度固定为 18 字节。「数据」的长度最短为 46 字节，最长为 1500 字节。因此，整个「帧」最短为 64 字节，最长为 1518 字节。如果数据很长，就必须分割成多个帧进行发送。

### 发送数据

链路层之所以可以在多台计算机之间传送数据，靠的是 MAC 地址去寻找接收者，方式是通过**广播**（ broadcasting ）的方式：

    向本网络内所有计算机发送，让每台计算机自己判断接收方的 MAC 地址是否与自身的 MAC 地址匹配，然后确定自己是否为接收方，如果是，就接受这个包，否则丢弃这个包。

---

## 网络层

按链路层中所述，以广播的方式向本网络上所有计算机发送数据包，这样不仅**效率低**，而且只能局限于发送方所在的**子网络**。

所以我们需要一种方法，来区分哪些 MAC 地址属于同一个子网络，哪些不是。

如果是同一个子网络，就采用**广播**方式发送，否则就采用**路由**方式发送。

这就导致了「网络层」的诞生。它的作用是引进一套新的地址，让我们能够区分不同的计算机「是否属于同一个子网络」。这套地址就叫做**网络地址**，简称**网址**。网络地址是由管理员分配的。

### IP 协议

规定网络地址的协议，叫做 **IP 协议**。它所定义的地址，就被称为 **IP 地址**。

根据「IP 地址」和「子网掩码」，我们可以判断两个 IP 地址是否处于同一子网。

    方法是将两个 IP 地址与子网掩码分别进行 AND 运算（ 两个数位都为 1，运算结果为 1，否则为 0 ），得到的结果如果一致表示处于同一个子网，否则反之。

**IP 协议的作用**：为每一台计算机分配 IP 地址，以及确定哪些地址在同一个子网络。

* 思考

  然后，我们来想一个问题，以太网数据包中并没有 IP 地址的栏位，我们如何发送 IP 数据包（ 根据 IP 协议发送的数据 ）呢？

  其实，可以把 IP 数据包直接放进以太网数据包的「数据」部分，因此完全不用修改以太网的规格。

  这就是互联网分层结构的好处：**上层的变动完全不涉及下层的结构**。

* IP 数据包也分为：「标头」和「数据」两个部分。

  **标头**：主要包括版本、长度、IP 地址等信息。长度为 20 到 60 字节。

  **数据**：IP 数据包的具体内容。总长度最大为 65535 字节。如果 IP 数据包超过了 1500 字节，它就需要分割成几个以太网数据包，分开发送了。

### ARP 协议

> 因为 IP 数据包是放在以太网数据包里发送的，所以如果我们需要发送数据，就必须知道目标主机的 IP 地址以及 MAC 地址。

**ARP 协议**可以通过 IP 地址判断两台主机是否存在于同一个子网络，如果处于同一个子网络，它会以广播的形式发送给每一台主机，如果 IP 地址匹配，对应的主机就会告知自己的 MAC 地址。

如果不处于同一个子网络，只能把数据包传送到两个子网络连接处的「网关」（ gateway ），让网关去转发。

❗️ 但是在链路层也会因为不知道目的 MAC 地址而触发 ARP 协议，导致许多资料将 ARP 协议归入链路层，但是以 TCP/IP 模型为基准，将其定义的所有协议放在网络层上。

---

## 传输层

> 现在，我们有了 MAC 地址和 IP 地址，我们已经可以在互联网上任意两台主机上建立通信。

❓ 接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？

也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做「端口」（ port ），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

**端口**：一个整数，范围为 0 到 65535，也就是 16 个二进制位

所以，传输层应运而生。

### UDP 协议

UDP 数据包，也是由「标头」和「数据」两部分组成。

**标头**：主要定义了发出端口和接收端口。一共只有 8 个字节。

**数据**：需要发送的具体的内容。加上标头，总长度不超过 65535 字节，刚刚好一个 IP 数据包的长度。

然后将整个 UDP 数据包放入 IP 数据包的「数据」部分。

### TCP 协议

**优点**：能够确保数据不会遗失，拟补了 UDP 协议可靠性较差的确定。

**缺点**：过程复杂、实现困难、消耗较多的资源。

TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割。

---

## 应用层

> 应用程序收到「传输层」的数据后，数据来源五花八门，应该如何解读呢？

举个例子：TCP 协议可以为各种各样的程序传递数据，比如 Email、WWW、FTP 等等。那么，必须有不同协议规定电子邮件、网页、FTP 数据的格式，这些应用程序协议就构成了「应用层」。

应用层的数据就放在 TCP 数据包的「数据」部分。

---

## 总结

**实体层**：负责传送 0 和 1 的电信号。

**链接层**：在实体层的上方，确定了 0 和 1 的分组方式。（ 以太网协议，触发 ARP 协议以寻找指定的 MAC 地址 ）

**网络层**：建立「主机到主机」的通信（ 主机由 IP 和 MAC 地址定位 ）。通过 IP 地址判断两台主机是否在同一个子网（ IP 协议 ），然后选择获取 MAC 地址的方式，如果处于同一子网，通过广播的方式寻找 MAC 地址（ ARP 协议 ）。

**传输层**：建立「端口到端口」的通信（ TCP / UDP 协议 ）。只要确定主机和端口，我们就能实现程序之间的交流。Unix 系统就把「主机 + 端口」称作「套接字」（ socket ）。

最后，一个以太网的数据包变成：

**以太网标头** + **IP 标头** + **TCP / UDP 标头** + **应用层数据包**

也就是：

**发送、接收者 MAC 地址** + **发送、接收方的 IP 地址，IP 版本、长度** + **发出、接受端口** + **应用层数据**

---

## 用户角度

接下来从用户的角度看待这些协议如何互动。

我们如果需要发送一个数据包，根据上面的内容，我们需要知道：

- 对方的 MAC 地址
- 我们的 MAC 地址
- 对方的 IP 地址
- 我们的 IP 地址、信息
- 对方接受数据包的端口
- 我们发出数据包的端口

其中，我们的 MAC 地址是一个已知信息。

其他的内容，当我们第一次接入互联网之前都是不知道的，先说说如何获取我们自己的 IP 信息。

### 动态 IP 地址

所谓「动态IP地址」，指计算机开机后，会自动分配到一个 IP 地址，不用人为设定。它使用的协议叫做 **DHCP 协议**。

这个协议规定，每一个子网络中，都有一台「DHCP 服务器」负责管理本网络的所有 IP 地址。

新的计算机想要加入网络，必须向「DHCP 服务器」发送一个「DHCP 请求」数据包，申请 IP 地址和相关的网络参数。

### DHCP 协议

前面说了需要向「DHCP 服务器」发送一个「DHCP 请求」数据包，但是我们如何知道 DHCP 服务器的位置呢？

我们需要获取 IP 地址和相关的网络参数，可以通过「DHCP 协议」得到。

发送数据包之前，我们需要知道「DHCP 服务器」的 MAC 地址以及 IP 地址，可是这两个都不知道，所以「DHCP 协议」规定：

- 以太网标头：填写自身的 MAC 地址（ 发送方 ）和 `FF-FF-FF-FF-FF-FF`（ 接收方 ）

    这里接收方填写的 `FF-FF-FF-FF-FF-FF` 表示这是一个**广播**，因为我们并不知道 DHCP 服务器的 MAC 地址。

- IP 标头：由于不知道自身以及 DHCP 服务器的 IP 地址，所以填写 `0.0.0.0`（ 发送方 ）和 `255.255.255.255`（ 接收方 ）
- UDP 标头：设置发出方的端口和接收方的端口。这一部分是 DHCP 协议规定好的，发出方是 **68** 端口，接收方是 **67** 端口。

**DHCP 服务器获取数据包**：

填写好这些信息就可以将这个数据包以广播的形式发送，同一子网中的每台主机都会收到这个数据包，由于从「接收方 MAC 地址」看不出这个是发给谁的，所以需要分析查看这个包的「接收方 IP 地址」以确定这个包不是发给自己的。

当「DHCP 服务器」看到发出方 IP 地址是 `0.0.0.0`，接收方是 `255.255.255.255`，就明白这个包是发给自己的，接收该数据包。

**DHCP 服务器处理并响应**：

DHCP 服务器会读出这个包的数据内容，分配好 IP 地址后，发送一个「DHCP 响应」，在这个数据包中填入：

- 以太网标头：填入双方的 MAC 地址。
- IP 标头：DHCP 服务器的IP地址（ 发出方 ）和 `255.255.255.255`（接收方）。
- UDP 标头：**67** 端口（ 发出方 ）和 **68**（ 接收方 ）。
- 数据部分：分配给请求端的 IP 地址和本网络的具体参数。

**用户接收**：

用户接收到 DHCP 服务器发送的响应包，就能够知道自己的 IP 地址、子网掩码、网关地址、DNS 服务器等等参数。

## 实例访问网址 www.google.com

首先我们通过 DNS 服务器地址（ 前面通过 DHCP 协议获得 ）发送一个 DNS 数据包（ 53 端口 ）获取访问目标的 IP 地址。

接下来配合子网掩码判断子网，如果处于同一子网络，将通过 ARP 协议获取目标的 MAC 地址，如果处于不同子网，则需要通过网关进行转发（ 接收方的 MAC 地址填写网关的 MAC 地址 ）。

**该包的结构**：

**以太网标头** + **IP 标头** + **TCP 标头** + **HTTP 数据包**

- **HTTP 数据包部分**（ 假设数据包长度为 4960 字节 ）

    ```
    GET / HTTP/1.1
    Host: www.google.com
    Connection: keep-alive
    User-Agent: Mozilla/5.0 (Windows NT 6.1) ......
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Encoding: gzip,deflate,sdch
    Accept-Language: zh-CN,zh;q=0.8
    Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
    Cookie: ... ...
    ```

- **TCP 协议**：

    TCP 数据包需要设置端口，接收方（ www.google.com ）默认是 80 端口，发送方是本机的端口，是一个 1024-65535 之间随机的整数。

    TCP 标头的长度为 20 字节，数据部分为接入的 HTTP 的数据包，总长度为 4980 字节。

- **IP 协议**：

    IP 数据包需要设置双方的 IP 地址，这是已知的，发送方是 `192.168.1.100`（ 本机 ），接收方是 `172.194.72.105`（ Google ），接收方地址由前面的 DNS 服务器获取。

    IP 标头的长度为 20 字节，数据部分为接入的 TCP 数据包，总长度变为 5000 字节。

- **以太网协议**：

    以太网数据包需要设置双方的 MAC 地址，发送方为本机的网卡 MAC 地址，接收方为网关 `192.168.1.1` 的 MAC 地址（ 通过 ARP 协议得到 ）。
    
    由于以太网数据包的**数据部分**最大长度为 1500 字节，现在 IP 数据包长度为 5000，所以必须分割成 4 个包：1500 + 1500 + 1500 + 560
    
    其中：1500 为 20 字节的 IP 标头加上 1480 字节的 TCP 数据包，最后的 560 为 5000 - 20( TCP 数据包长度 ) - 1480 - 1480 -1480( 减去三个 TCP 数据包长度 ) + 20( 加上一个 IP 标头长度 )。

**服务器端响应**：

服务端接收到这 4 个包，根据标头的序号，将其拼成一个完整的包，读出里面的「HTTP 请求」，做出「HTTP 响应」，用 TCP 协议发送给客户端。

**客户端接收响应**：

客户端收到 HTTP 响应以后，就可以将网页显示出来，完成一次网络通信。