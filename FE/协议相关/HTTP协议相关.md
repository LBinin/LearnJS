## 概述

HTTP 是基于 TCP/IP 协议的「应用层」协议。它不涉及数据包（ packet ）传输，主要规定了客户端和服务器之间的通信格式，默认使用 **80** 端口。于 1991 年发布。

## HTTP / 0.9

该版本极其简单，只有一个 **GET** 命令：

```
GET /index.html
```

上面命令表示：TCP 连接建立后，客户端向服务器请求 `index.html` 网页。

这个版本的协议规定，服务器**只能**回应 HTML 格式的字符串，不能回应别的格式。并且服务器发送完毕后，就关闭 TCP 连接。

## HTTP / 1.0

1996 年 5 月，HTTP/1.0 版本发布。

**版本增加功能**：

- 传输内容不局限于文字，任何格式的内容都可以发送，比如传输图像、视频、二进制文件等。
- 引入 **POST** 命令和 **HEAD** 命令，丰富了浏览器与服务器的互动手段。
- 每次通信都必须包括「头信息」（ HTTP header ），用来描述一些元数据。
- 新增状态码（ status code ）、多字符集支持、多部分发送（ multi-part type ）、权限（ authorization ）、缓存（ cache ）、内容编码（ content encoding ）等。

**缺点**：

HTTP/1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢。

所以，HTTP/1.0 版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。

为了解决这个问题，有些浏览器在请求时，用了一个**非标准**的 `Connection` 字段。

```
Connection: keep-alive
```

这个字段要求服务器不要关闭 TCP 连接，以便其他请求复用。服务器同样回应这个字段。

```
Connection: keep-alive
```

**请求格式**：

```
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

这时，必须在第一行的尾部添加协议版本。后面的多行头信息都是用来描述客户端的信息。

**回应格式**：

```
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

第一行为「协议版本」+「状态码」+「状态描述」

空行上方为「头信息」，下方为「数据」

## HTTP / 1.1

1997 年 1 月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年，却一直用到了 21 年后的今天，直到现在还是最流行的版本。

**版本新增内容**：

- 新增动词方法：`PUT`、`PATCH`、`HEAD`、`OPTIONS`、`DELETE`。
- 新增 `Host`字段，用来指定服务器的域名。

    ```
    Host: www.example.com
    ```

    这样就可以将请求发往「同一台服务器」上的「不同网站」，为虚拟主机的兴起打下了基础。

- 引入了「持久连接」，即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 `Connection: keep-alive`。对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。
- 引入了「管道机制」，在同一个 TCP 连接里面，客户端可以同时发送多个请求。

    以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。

    「管道机制」允许浏览器同时发出 A 请求和 B 请求，但是服务器还是**按照顺序**，先回应 A 请求，完成后再回应 B 请求。

- 增加 `Content-length` 字段，声明本次回应的数据长度。

    由于 HTTP/1.1 之前的版本都是发送完数据包就关闭了 TCP 连接，所以不需要该字段。

    ```
    Content-Length: 3495
    ```

    上面内容表示：本次回应的长度是 3495 个字节，后面的字节属于下一个回应。
    
    这种方式的前提条件是：**服务器发送回应之前，必须知道回应的数据长度**。

- 可使用「分块传输编码」，在头信息添加 `Transfer-Encoding: chunked`，表明回应将由数量未定的数据块组成。

    对于一些耗时的动态操作，可以当产生一块数据，就发送一块，采用「流模式」取代「缓存模式」，而不是等到所有操作完成，才能发送数据。

    ```
    HTTP/1.1 200 OK
    Content-Type: text/plain
    Transfer-Encoding: chunked

    25
    This is the data in the first chunk

    1C
    and this is the second one

    3
    con

    8
    sequence

    0
    ```

    每个非空的**数据块**之前，会有一个 16 进制的数值，表示这个「块的长度」。最后是一个大小为 0 的块，就表示本次回应的数据发送完了。

**缺点**：

虽然 HTTP/1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是「按次序进行」的。

服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」（ Head-of-line blocking ）。

为了避免这个问题，只有两种方法：

1. 减少请求数。
2. 同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（ domain sharding ）等等。

如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。

## HTTP/2

2015 年，HTTP/2 发布。因为标准委员会不打算再发布子版本，所以没有称为 2.0，下一个版本将是 HTTP/3

**新特性**：

- 二进制协议

    HTTP/2 则是一个彻底的「二进制协议」，头信息和数据体都是二进制，并且统称为「帧」（ frame ）。分为**头信息帧**和**数据帧**。

    HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。

- 多工

    HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了「队头堵塞」。

    这样双向的、实时的通信，就叫做多工（Multiplexing）。

- 数据流

    HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（ stream ）。每个数据流都有一个独一无二的编号。
    
    数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。

    数据流发送到一半的时候，客户端和服务器都可以发送信号（ RST_STREAM 帧 ），来取消这个数据流。HTTP/1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。
    
    另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。

- 头信息压缩

    由于 HTTP 协议是无状态的，之前版本的 HTTP 协议在每一次发送请求的时候都会发送重复的信息，比如 `Cookie` 和 `User Agent`，这不仅会浪费很多带宽，也影响速度

    HTTP/2 对这一点做了优化，引入了头信息压缩机制（ header compression ）。
    
    一方面，头信息使用 **gzip** 或 **compress** 压缩后再发送；
    
    另一方面，客户端和服务器同时维护一张「头信息表」，所有字段都会存入这个表，生成一个**索引号**，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

- 服务器推送

    HTTP/2 允许服务器未经请求，主动向客户端发送资源。