### 简介

**Node** 是 JavaScript 语言的服务器运行环境。

**Node** 内部采用 Google 公司的 V8 引擎，作为 JavaScript 语言解释器；通过自行开发的 libuv 库，调用操作系统资源。

---

### 异步操作

**Node** 采用 V8 引擎处理 JavaScript 脚本，最大特点就是**单线程运行**，一次只能运行一个任务。

这导致 **Node** 大量采用异步操作（ asynchronous opertion ），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。

由于这种特性，某一个任务的后续操作，往往采用回调函数（ callback ）的形式进行定义。

**Node** 约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。

为什么要这么做呢？

> 这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制 `try…catch` 对于异步操作行不通，所以只能把错误交给回调函数处理。

举个例子：

```javascript
try {
  db.User.get(userId, function(err, user) {
    if(err) {
      throw err
    }
    // ...
  })
} catch(e) {
  console.log(‘Oh no!’)
}
```

在上面代码中，`db.User.get` 方法是一个**异步操作**，等到抛出错误时，可能它所在的 `try…catch` 代码块早就运行结束了，这会导致错误无法被捕捉。

所以，**Node** 统一规定，一旦异步操作发生错误，就把错误对象传递到回调函数。

如果没有发生错误，回调函数的第一个参数就传入 `null`。

这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。另外，这样还可以层层传递错误。

---

### 全局对象和全局变量

**Node** 提供以下几个全局对象，它们是所有模块都可以调用的：

- `global`：表示 **Node** 所在的全局环境，类似于浏览器的 `window` 对象。

    需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如 `var x = 1` 等同于设置 `window.x = 1`。
    
    但是 **Node** 不是这样，至少在模块中不是这样（ REPL环境的行为与浏览器一致 ）。在模块文件中，声明 `var x = 1`，该变量不是 `global` 对象的属性，`global.x` 等于 `undefined`。
    
    这是因为某个模块的**全局变量**都是该模块「私有」的，其他模块无法取到，所以是不会放在 `global` 全局对象上的。

- `process`：该对象表示 **Node** 所处的当前进程，允许开发者与该进程互动。

- `console`：指向 **Node** 内置的 `console` 模块，提供命令行环境中的标准输入、标准输出功能。

当然，`Node` 还提供一些全局函数：

- `setTimeout()`：用于在指定毫秒之后，运行回调函数。

    实际的调用间隔，还取决于系统因素。间隔的毫秒数在 **1** 毫秒到 **2,147,483,647** 毫秒（ 约 24.8 天 ）之间。如果超过这个范围，会被自动改为 **1** 毫秒。该方法返回一个整数，代表这个新建定时器的**编号**。

- `clearTimeout()`：用于终止一个 `setTimeout` 方法新建的定时器。
- `setInterval()`：用于每隔一定毫秒调用回调函数。

    由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是 **1** 到 **2,147,483,647** 毫秒（ 大约 24.8 天 ）之间的整数，如果超过这个范围，会被自动改为 **1** 毫秒。该方法返回一个整数，代表这个新建定时器的**编号**。

- `clearInterval()`：终止一个用 `setInterval` 方法新建的定时器。
- `require()`：用于加载模块。
- `Buffer()`：用于操作二进制数据。

同时，**Node** 还提供两个全局变量，都以两个下划线开头：

- `__filename`：指向当前运行的脚本**文件名**。
- `__dirname`：指向当前运行的脚本**所在的目录**。

除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是「伪全局变量」，主要为 `module`, `module.exports`, `exports` 等。

---

### 模块化结构

**Node.js** 采用模块化结构，按照 [CommonJS 规范](./CommonJS规范.md) 定义和使用模块。

模块与文件是一一对应关系，即加载一个「模块」，实际上就是加载对应的一个「模块文件」。

1. 模块加载

    指定加载模块用的是 `require` 命令，参数为模块名，可以省略脚本文件的后缀名，返回一个**模块导出对象**。

    `require` 方法的参数要分为两种情况：

    1. 第一种情况是参数中含有文件路径（ 比如 `var circle = require('./circle')` ），这时路径是相对于当前脚本所在的目录。
    2. 第二种情况是参数中不含有文件路径，这时 **Node** 会到模块的「安装目录」，去寻找已安装的模块（ 比如 `var bar = require('bar')` ）。

    模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块中的内容实际上只会执行一次。
    
    如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。

2. 核心模块

    如果只是在服务器运行 JavaScript 代码，用处并不大，因为服务器脚本语言已经有很多种了。
    
    **Node.js** 的用处在于，它本身还提供了一系列「功能模块」，与**操作系统互动**。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。

    - `http`：提供HTTP服务器功能。
    - `url`：解析URL。
    - `fs`：与文件系统交互。
    - `querystring`：解析URL的查询字符串。
    - `child_process`：新建子进程。
    - `util`：提供一系列实用小工具。
    - `path`：处理文件路径。
    - `crypto`：提供加密和解密功能，基本上是对OpenSSL的包装。

3. 自定义模块

    **Node** 模块采用 CommonJS 规范。只要符合这个规范，就可以自定义模块。

---

### 异常处理

**Node** 有三种方法，传播一个错误：

1. 使用 `throw` 语句抛出一个错误对象，即抛出异常。

    最常用的捕获异常的方式，就是使用 `try…catch` 结构。但是，这个结构无法捕获异步运行的代码抛出的异常。

    所以，一种解决方法是将错误捕获代码，也放到异步执行。

    但是一般来说，**Node** 只在很少场合才用 `try/catch` 语句，比如使用 `JSON.parse` 解析 `JSON` 文本。

1. 将错误对象传递给回调函数，由回调函数负责发出错误。

    **Node** 采用的方法，是将错误对象作为第一个参数，传入回调函数。这样就避免了捕获代码与发生错误的代码不在同一个时间段的问题。

1. 通过 `EventEmitter` 接口，发出一个 `error` 事件。

    记得在实例化之后，对 `error` 事件部署监听函数，不然会导致应用程序崩溃。

    ```javascript
    var EventEmitter = require('events').EventEmitter
    var emitter = new EventEmitter()
    // 添加监听事件`
    emitter.on('error', function(err) {
      console.error('出错：' + err.message)
    })

    emitter.emit('error', new Error('something bad happened'))
    ```