##  1. 为什么 `[1] == [1]` 为 `false` ? 

首先需要搞懂 `==` 和 `===` 的关系

**`===` 判断规则：**

如果 **类型** 不同，就 `不相等` 
	
如果两个值都是 `数值` ，并且是同一个值，那么 `相等` ( `!` 例外) 

如果两个值都是 `字符串` ，每个位置的字符都一样，那么 `相等` ，否则 `不相等` 。

如果两个值都是 `true` ，或者都是 `false` ，那么 `相等` 。 

如果两个值都是 `对象` ，且都引用自 **同一个** 对象或函数，那么 `相等` ，否则 `不相等` 。 

如果两个值都是 `null` ，或者都是 `undefined` ，那么 `相等` 。 

如果其中至少有一个是 `NaN` ，那么 `不相等` 。

**`==` 判断规则：**

如果两个值 `类型` 相同，进行 `===` 比较。 

如果两个值 `类型` 不同，他们可能相等。根据下面规则进行类型转换再比较： 

如果一个是 `null ` 、一个是 `undefined ` ，那么 `相等` 。 

如果一个是 `字符串` ，一个是 `数值` ，把 **字符串转换成数值** 后再进行比较。 

如果任一值是 `true` ，把它转换成 **1** 再比较；如果任一值是 `false` ，把它转换成 **0** 再比较。 

如果一个是 `对象` ，另一个是 `数值或字符串` ，把 **对象转换成基础类型** 的值再比较。对象转换成基础类型在第 **2** 点有提到。

任何其他组合，都 `不相等` 。

因为这两个 **Array** 对象不属于同一个 **引用对象** ，所以，这两个数组之间的比较结果为 **false** 。

## 2. 那为什么 `[1] == 1` 为 `true` ?

这是因为 `[1]` 在和 `1` 进行比较的时候，首先会被转成数字类型，而转成数字类型在实现上又是通过 **new Number()** 来完成的。

所以，`[1] == 1` 会变成 `(new Number([1])).valueOf() == 1` 。

同时，`Number` 的构造函数其实是接受一个 **字符串** 作为参数的，加上 `[1].toString()` === `'1'`，所以 `new Number([1])` 相当于写 `new Number('1')`，于是很显然 `(new Number([1])).valueOf()` 就是 1 了。

个人总结：如果一边是对象，一边是基本类型，JavaScript 会先将对象使用抽象操作 `ToPrimitive` 将对象转换成基本类型 ( Primitive ) 之后再进行比较，之后就是基本类型之间的比较了。
 
一个对象转化为基本类型的步骤如下：

> 1. 先调用该对象的 `valueOf()` 方法，如果返回值为 `基本类型` ，这个值就是最终值。
> 2. 否则，继续调用对象的 `toString()` 方法，如果返回值为 `基本类型` ，这个值就是最终值。
> 3. 都无法得到结果的话，抛出异常 `Error: Cannot convert object to primitive value` 。

    如果对象是 Date 实例，则先执行 toString() 方法

## 3. 对象深浅复制

**浅复制**

该复制方式只是**对象的引用**，obj2 与 obj1 的地址相同，任意一个被修改，另一个对象的内容也被修改。

```javascript
var obj1 = { a: 1, b : 2 }
var obj2 = obj1
```

**深复制**

有时候，我们想对对象实现值的复制，而不是对象的引用，这时候就需要**深复制**。

```javascript
function copy(obj) {
  var copy = Object.create(Object.getPrototypeOf(obj))
  var propNames = Object.getOwnPropertyNames(obj)

  propNames.forEach(function(name) {
    var desc = Object.getOwnPropertyDescriptor(obj, name)
    Object.defineProperty(copy, name, desc)
  })

  return copy
}

var obj1 = { a: 1, b: 2 }
var obj2 = copy(obj1) // obj2 looks like obj1 now
```

```javascript
var cloneObj = function(obj){
    var str, newobj = obj.constructor === Array ? [] : {}
    if(typeof obj !== 'object'){
        return
    } else if(window.JSON){
        str = JSON.stringify(obj), //系列化对象
        newobj = JSON.parse(str) //还原
    } else {
        for(var i in obj){
            newobj[i] = typeof obj[i] === 'object' ? 
            cloneObj(obj[i]) : obj[i] 
        }
    }
    return newobj
}
```